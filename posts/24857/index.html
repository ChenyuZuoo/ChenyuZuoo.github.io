<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Einstiegen bitte!"><meta name="google-site-verification" content="L7-zLUxhF4WYJprTtGO0jUL7BYmE9BrpzuwU7s_XEJI"><title>「译」JavaScript对象生命周期(Eloquent JavaScript 第六章) | Chenyu's Script</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-91094510-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">「译」JavaScript对象生命周期(Eloquent JavaScript 第六章)</h1><a id="logo" href="/.">Chenyu's Script</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about.html"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">「译」JavaScript对象生命周期(Eloquent JavaScript 第六章)</h1><div class="post-meta">May 17, 2017<span> | </span><span class="category"><a href="/categories/JavaScript/">JavaScript</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="posts/24857/" href="/posts/24857/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#历史"><span class="toc-number">1.</span> <span class="toc-text">历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-number">2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型"><span class="toc-number">3.</span> <span class="toc-text">原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造器"><span class="toc-number">4.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写"><span class="toc-number">5.</span> <span class="toc-text">重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型实例化"><span class="toc-number">6.</span> <span class="toc-text">原型实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无原型对象"><span class="toc-number">7.</span> <span class="toc-text">无原型对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-number">8.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#表格处理"><span class="toc-number">9.</span> <span class="toc-text">表格处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取器和设置器"><span class="toc-number">10.</span> <span class="toc-text">获取器和设置器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">11.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INSTANCEOF运算符"><span class="toc-number">12.</span> <span class="toc-text">INSTANCEOF运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">13.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>此文翻译《Eloquent Javascript》中第六章，<a href="http://eloquentjavascript.net/06_object.html" target="_blank" rel="noopener">The Secret Life of Objects</a>，侵删。<br>该书有中文译本出版。此译文仅作交流学习之用。</p>
<hr>
<blockquote>
<p>面向对象的编程语言的问题在于，它们携带了一些隐形的环境。你只是想要一根香蕉，但你得到的是一个拿着香蕉的猴子，和一整个丛林。<br>—— Joe Armstrong, interviewed in Coders at Work</p>
</blockquote>
<hr>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>就像大多数编程故事一样，这个故事也从一个复杂的问题开始。讲道理，把一个复杂的问题分割为很多个小问题，它就变得可控了。这些“小问题”就叫做<code>对象</code>。<br>一个对象就像是一个坚硬的外壳，它隐藏了晦涩的内部信息，给我们提供的了一些旋钮和连接器，在这里就是使用对象的<code>接口</code>（比如不同的方法）。这样的机制能让我们忽略其复杂的内部工作原理，使用相对简单的接口。<br><img src="/images/tra_object1.jpg" alt="对象"><br>举个例子，你可以想象一个对象在电脑屏幕的一个区域提供接口，你就可以在屏幕的这个区域写字或者画画。至于这些形状是如何变为像素点的具体过程，就隐藏在对象内部了。在这里，为了使用这个对象，你需要了解它的一些方法，比如<code>drawCircle</code>。<br>在1970和80年代，这个思想最初进入应用。在1990年代，这个概念随着面向对象编程技术革命被炒得很热。一夜之间，很多人跳出来说只有面向对象才是正确的编程方式，没有对象的语言都是垃圾。<br>狂热终将导致不切实际的愚蠢，那时候就已经出现了一些<code>对象</code>的反对派。现在在某些圈子里，<code>对象</code>的名声并不好。<br>相对于理论派，我更倾向于实践主义。面向对象还有很多有用的概念，最重要的就是<code>封装</code>（用于区分内部复杂性和外部接口）。很值得学习。<br>这一章主要讲的就是JavaScript中的对象，和一些经典的面向对象的使用技术。</p>
<hr>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>方法</code>就是包含函数的简单属性。下面是一个简单的方法：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rabbit = &#123;&#125;;</span><br><span class="line">rabbit.speak = <span class="function"><span class="keyword">function</span>(<span class="params">line</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"The rabbit says '"</span> + line + <span class="string">"'"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rabbit.speak(<span class="string">"I'm alive."</span>);</span><br><span class="line"><span class="comment">// → The rabbit says 'I'm alive.'</span></span><br></pre></td></tr></table></figure>
<p>通常情况下，当一个对象的方法被调用时，总是需要做事情的。当一个函数被当作方法<code>object.method()</code>调用时（被当作一个属性来查找，而且立即执行），函数体内的特殊变量<code>this</code>就会指向被调用的对象。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">line</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"The "</span> + <span class="keyword">this</span>.type + <span class="string">" rabbit says '"</span> +</span><br><span class="line">              line + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> whiteRabbit = &#123;<span class="attr">type</span>: <span class="string">"white"</span>, <span class="attr">speak</span>: speak&#125;;</span><br><span class="line"><span class="keyword">var</span> fatRabbit = &#123;<span class="attr">type</span>: <span class="string">"fat"</span>, <span class="attr">speak</span>: speak&#125;;</span><br><span class="line"></span><br><span class="line">whiteRabbit.speak(<span class="string">"Oh my ears and whiskers, "</span> +</span><br><span class="line">                  <span class="string">"how late it's getting!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// → The white rabbit says 'Oh my ears and whiskers, how</span></span><br><span class="line"><span class="comment">//   late it's getting!'</span></span><br><span class="line">fatRabbit.speak(<span class="string">"I could sure use a carrot right now."</span>);</span><br><span class="line"><span class="comment">// → The fat rabbit says 'I could sure use a carrot</span></span><br><span class="line"><span class="comment">//   right now.'</span></span><br></pre></td></tr></table></figure>
<p>这段代码使用<code>this</code>关键词用于输出正在说话的兔子的类型。回想一下<code>apply</code>和<code>bind</code>方法，它们的第一个参数都可以用来模拟方法的调用。第一个参数实际上是给<code>this</code>传值。<br>还有一个和<code>apply</code>类似的方法，叫做<code>call</code>。它也调用了方法中包含的函数，但是它传递的是更普遍的参数，而不是一个数组。类似于<code>apply</code>和<code>bind</code>，<code>call</code>也给<code>this</code>传递了特殊的值。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">speak.apply(fatRabbit, [<span class="string">"Burp!"</span>]);</span><br><span class="line"><span class="comment">// → The fat rabbit says 'Burp!'</span></span><br><span class="line">speak.call(&#123;<span class="attr">type</span>: <span class="string">"old"</span>&#125;, <span class="string">"Oh my."</span>);</span><br><span class="line"><span class="comment">// → The old rabbit says 'Oh my.'</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>仔细看：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(empty.toString);</span><br><span class="line"><span class="comment">// → function toString()&#123;…&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(empty.toString());</span><br><span class="line"><span class="comment">// → [object Object]</span></span><br></pre></td></tr></table></figure>
<p>我从空对象里输出了一个值。神奇！<br>好吧，这并不是真的。我只是保留了JavaScript对象的工作信息。<code>对象</code>除了很多属性之外，几乎所有的<code>对象</code>都有<code>原型</code>。<code>原型</code>是另外一个作为属性回退的<code>源对象</code>。当请求一个对象不存在的属性时，就会在它的<code>原型</code>里寻找，再去原型的原型里寻找，以此类推。<br>所以控对象的原型是什么呢？就是几乎所有原型的祖先<code>Object.prototyp</code>。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(&#123;&#125;) ==</span><br><span class="line">            <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype));</span><br><span class="line"><span class="comment">// → null</span></span><br></pre></td></tr></table></figure>
<p>如你所料，<code>Object.getPrototypeOf</code>函数返回的是对象的原型。<br>JavaScript的原型关系是一个树状结构，这个树的根节点就是<code>Object.prototype</code>。它提供的一些方法，几乎在所有的对象中都可以使用，比如<code>toString</code>，作用是把对象作为字符串输出。<br>很多对象的直接原型都不是<code>Object.prototype</code>，但他们有自己的原型，提供他们自己的默认属性。函数的原型是<code>Function.prototype</code>，数组的原型是<code>Array.prototype</code>。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">isNaN</span>) ==</span><br><span class="line">            <span class="built_in">Function</span>.prototype);</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf([]) ==</span><br><span class="line">            <span class="built_in">Array</span>.prototype);</span><br><span class="line"><span class="comment">// → true</span></span><br></pre></td></tr></table></figure>
<p>以上的原型对象也有自己的原型，通常是<code>Object.prototype</code>。所以间接地，还是提供了比如<code>toString</code>这样的方法。<br>显然，<code>Object.getPrototypeOf</code>函数返回的是一个对象的原型。你可以使用<code>Object.create</code>创建新的原型。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> protoRabbit = &#123;</span><br><span class="line">  speak: <span class="function"><span class="keyword">function</span>(<span class="params">line</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"The "</span> + <span class="keyword">this</span>.type + <span class="string">" rabbit says '"</span> +</span><br><span class="line">                line + <span class="string">"'"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> killerRabbit = <span class="built_in">Object</span>.create(protoRabbit);</span><br><span class="line">killerRabbit.type = <span class="string">"killer"</span>;</span><br><span class="line">killerRabbit.speak(<span class="string">"SKREEEE!"</span>);</span><br><span class="line"><span class="comment">// → The killer rabbit says 'SKREEEE!'</span></span><br></pre></td></tr></table></figure>
<p><code>兔子原型</code>就像一个容器，存放了所有兔子共有的属性。一个具体的兔子，比如本例中的killer rabbit，从它的原型中继承共有属性，但这个对象只包含了它自己的属性。</p>
<hr>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>一个创建对象的更方便的方法，就是使用一个共有的原型<code>constructor</code>。在JavaScript中，在函数前面加上关键词<code>new</code>，会被当作一个构造器处理。构造器的<code>this</code>变量会绑定给一个新的对象，调用后会返回这个新对象，除非是指定返回别的对象例外。<br>利用<code>new</code>新建的对象，称做构造器的实例化。<br>下面是一个兔子简单的构造器。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> killerRabbit = <span class="keyword">new</span> Rabbit(<span class="string">"killer"</span>);</span><br><span class="line"><span class="keyword">var</span> blackRabbit = <span class="keyword">new</span> Rabbit(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(blackRabbit.type);</span><br><span class="line"><span class="comment">// → black</span></span><br></pre></td></tr></table></figure>
<p>构造器（或者说全体函数）都会自动获得<code>prototype</code>这个属性，默认值为空，空对象继承自<code>Object.prototype</code>。任何一个由这个构造器实例化的对象都有原型。所以给兔子添加、<code>speak</code>方法，我们可以利用它的构造器简化：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rabbit.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params">line</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"The "</span> + <span class="keyword">this</span>.type + <span class="string">" rabbit says '"</span> +</span><br><span class="line">              line + <span class="string">"'"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">blackRabbit.speak(<span class="string">"Doom..."</span>);</span><br><span class="line"><span class="comment">// → The black rabbit says 'Doom...'</span></span><br></pre></td></tr></table></figure>
<p>了解原型和构造器之间的区别是很重要的，还有对象获得原型的方式。<code>原型</code>通过构造器给定，获取对象的原型要使用<code>Object.getPrototypeOf</code>。构造器的原型是<code>Function.prototype</code>，因为构造器本质是函数。它的原型属性用于指定它实例化的对象，但它自己的原型不是这个。</p>
<hr>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>当你给对象添加一个属性的时候，不论这个属性是不是来自于原型，这个属性都添加给了这个对象本身，由此它就有了自己的属性。如果原型中含有相同名称的属性，那么原型中的属性就不再影响该对象。原型本身的属性没有被改变。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rabbit.prototype.teeth = <span class="string">"small"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(killerRabbit.teeth);</span><br><span class="line"><span class="comment">// → small</span></span><br><span class="line">killerRabbit.teeth = <span class="string">"long, sharp, and bloody"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(killerRabbit.teeth);</span><br><span class="line"><span class="comment">// → long, sharp, and bloody</span></span><br><span class="line"><span class="built_in">console</span>.log(blackRabbit.teeth);</span><br><span class="line"><span class="comment">// → small</span></span><br><span class="line"><span class="built_in">console</span>.log(Rabbit.prototype.teeth);</span><br><span class="line"><span class="comment">// → small</span></span><br></pre></td></tr></table></figure>
<p>下面的图就是代码运行后，它内部处理的情况。<code>Rabbit</code>和<code>Object</code>原型就是<code>killerRabbit</code>的后备资源，当找不到它自己的属性时，就会顺着向上查找。<br><img src="/images/tra_object2.svg" alt="兔子原型"><br>重写属性也是原型的一个很有用的地方。如同例子中的兔子牙齿，在非特殊的对象中从原型中继承标准值，也允许特殊对象有自己不同的属性。<br>这一功能也使得数组原型具有不同的<code>toString</code>方法。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.toString ==</span><br><span class="line">            <span class="built_in">Object</span>.prototype.toString);</span><br><span class="line"><span class="comment">// → false</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>].toString());</span><br><span class="line"><span class="comment">// → 1,2</span></span><br></pre></td></tr></table></figure>
<p>调用数组的<code>toString</code>方法，返回值类似于调用<code>.join(&quot;,&quot;)</code>，在返回的数组中每个值之间添加逗号。数组直接调用<code>Object.prototype.toString</code>返回的是一个不同的字符串。函数并没有数组的概念，所以返回值是“object”再加它的数据类型，然后放在中括号中。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>, <span class="number">2</span>]));</span><br><span class="line"><span class="comment">// → [object Array]</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="原型实例化"><a href="#原型实例化" class="headerlink" title="原型实例化"></a>原型实例化</h3><p>基于原型给所有的对象添加属性或者方法随时都可以进行。举个例子，这个功能在给兔子添加跳舞方法就很必要。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rabbit.prototype.dance = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"The "</span> + <span class="keyword">this</span>.type + <span class="string">" rabbit dances a jig."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">killerRabbit.dance();</span><br><span class="line"><span class="comment">// → The killer rabbit dances a jig.</span></span><br></pre></td></tr></table></figure>
<p>这个功能很方便，但也会造成问题。在之前的章节，我们使用对象作为连接名字和给定值的方式。下面是<a href="http://eloquentjavascript.net/04_data.html#object_map" target="_blank" rel="noopener">第四章</a>的一个例子：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">storePhi</span>(<span class="params">event, phi</span>) </span>&#123;</span><br><span class="line">  map[event] = phi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">storePhi(<span class="string">"pizza"</span>, <span class="number">0.069</span>);</span><br><span class="line">storePhi(<span class="string">"touched tree"</span>, <span class="number">-0.081</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以在<code>for/in</code>循环中遍历对象中所有的phi值，并且使用<code>in</code>测试某个名字是否存在。但不幸的是，对象的原型会导致错误。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.nonsense = <span class="string">"hi"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> map)</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="comment">// → pizza</span></span><br><span class="line"><span class="comment">// → touched tree</span></span><br><span class="line"><span class="comment">// → nonsense</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"nonsense"</span> <span class="keyword">in</span> map);</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> map);</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete the problematic property again</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype.nonsense;</span><br></pre></td></tr></table></figure>
<p>这完全是错误的，在我们的数据集里就没有叫做“nonsense”的名字，而且肯定也没有“toString”。<br>奇怪的是，<code>for/in</code>循环中也没有出现<code>toString</code>，但是在<code>in</code>操作中返回的是<code>true</code>。这是因为JavaScript区分了可枚举和不可枚举属性。<br>通过<code>Object.defineProperty</code>我们可以自定义不可枚举属性，可以使我们控制创建的属性。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">"hiddenNonsense"</span>,</span><br><span class="line">                      &#123;<span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">"hi"</span>&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> map)</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="comment">// → pizza</span></span><br><span class="line"><span class="comment">// → touched tree</span></span><br><span class="line"><span class="built_in">console</span>.log(map.hiddenNonsense);</span><br><span class="line"><span class="comment">// → hi</span></span><br></pre></td></tr></table></figure>
<p>现在这个属性是存在的，但不会出现在循环里了。这点很好。但是<code>in</code>操作时对象的<code>Object.prototype</code>还是有问题的。为了解决这个问题，我们可以使用<code>hasOwnProperty</code>方法。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(map.hasOwnProperty(<span class="string">"toString"</span>));</span><br><span class="line"><span class="comment">// → false</span></span><br></pre></td></tr></table></figure>
<p>这个方法能绕过它自身的属性，查看它包含的属性。这个信息比<code>in</code>操作返回的信息更有用。<br>当你担心有人混淆了原型时（在自己的程序中加入别人的代码），我推荐你这样写<code>for/in</code>循环：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> map) &#123;</span><br><span class="line">  <span class="keyword">if</span> (map.hasOwnProperty(name)) &#123;</span><br><span class="line">    <span class="comment">// ... this is an own property</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="无原型对象"><a href="#无原型对象" class="headerlink" title="无原型对象"></a>无原型对象</h3><p>但是兔子问题不止于此。如果有人在我们的<code>map</code>中添加一个名称为<code>hasOwnProperty</code>的对象，并且把它的值设为42呢？那么<code>map.hasOwnProperty</code>调用的是它自身的属性，并且返回一个数值，而不是函数。<br>在这样的情况下，原型就成了一个阻碍，我们希望不存在原型。我们知道<code>Object.create</code>函数可以让我们创建自定义原型的对象。你可以指定它的原型为<code>null</code>，这样就创建了一个没有原型的新对象。对于像<code>map</code>这样的对象，任何只都可以作为它的属性，那么无原型对象正是我们需要的。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">map[<span class="string">"pizza"</span>] = <span class="number">0.069</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> map);</span><br><span class="line"><span class="comment">// → false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"pizza"</span> <span class="keyword">in</span> map);</span><br><span class="line"><span class="comment">// → true</span></span><br></pre></td></tr></table></figure>
<p>这样就好多了！我们不需要再通过笨办法，用<code>hasOwnProperty</code>去判断对象自身的属性。现在不管谁对<code>Object.prototype</code>做了什么，我们都可以安全的使用<code>for/in</code>循环。</p>
<hr>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>当你对一个对象调用<code>String</code>函数时（转化一个值为字符串），它会去调用<code>toString</code>方法返回一个新建的字符串。有一些对象自定义了<code>toString</code>方法，返回比<code>[object Object]</code>更有用的信息。<br>这只是这个强大用途的一个小小例子。当编写一段代码用以处理特定接口的对象时（本例中是<code>toString</code>方法），任何可用于支持这个接口的代码都可以接入，并且运行良好。<br>这个机制叫做<code>多态</code>，当然不涉及任何形态的变化。只要符合接口的要求，多态代码支持传入不同数据类型。</p>
<hr>
<h3 id="表格处理"><a href="#表格处理" class="headerlink" title="表格处理"></a>表格处理</h3><p>我将会给出一个更深入的例子来讲解普遍意义上面向对象的多态机制。例子是这样的：给定一个数组，创建一个格式化的字符串，要求行列对齐。比如：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name         height country</span><br><span class="line">------------ ------ -------------</span><br><span class="line">Kilimanjaro    5895 Tanzania</span><br><span class="line">Everest        8848 Nepal</span><br><span class="line">Mount Fuji     3776 Japan</span><br><span class="line">Mont Blanc     4808 Italy/France</span><br><span class="line">Vaalserberg     323 Netherlands</span><br><span class="line">Denali         6168 United States</span><br><span class="line">Popocatepetl   5465 Mexico</span><br></pre></td></tr></table></figure>
<p>我们建立表格的流程是这样，构建函数先输入每个单元格的宽和高，然后用这个信息确定行列的宽和高。然后构建函数去构建正确大小的单元格，最后把结果保存到一个字符串里。<br>这个格式化程序使用一个设计优良的接口和单元格对象通信。这样，这个程序支持的单元格并没有预先设定好。我们可以稍后再增加单元格格式，比如如果接口支持的话，不用改变程序，我们也可以给表头添加下划线。<br>以下为接口：</p>
<ul>
<li><code>minHeight()</code>返回的是一行的最小高度。</li>
<li><code>minWidth()</code>返回的是一个单元格的最小宽度。</li>
<li><code>draw(width, height)</code>返回的是一个<code>height</code>长度的数组，每一个都包含对应字符串的<code>width</code>长度。这就代表了单元格的内容。</li>
</ul>
<p>这里我会使用很多高阶数组方法，因为很合适这个例子。<br>程序的第一行用于计算一个单元格的最小列宽和行高。变量<code>row</code>保存的是一个嵌套的数组，每一个数组都代表一行单元格。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rowHeights</span>(<span class="params">rows</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rows.map(<span class="function"><span class="keyword">function</span>(<span class="params">row</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> row.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">max, cell</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.max(max, cell.minHeight());</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">colWidths</span>(<span class="params">rows</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rows[<span class="number">0</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">_, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rows.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">max, row</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.max(max, row[i].minWidth());</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下划线(_)开头的命名的变量，或者命名为单个的下划线，只是为了提高可读性，表示这个不使用这个参数。<br><code>rowHeights</code>函数不难理解，使用<code>reduce</code>去计算一行单元格的最大高度值，然后使用<code>map</code>去对每一行执行这个计算。<br><code>colWidths</code>略有一点变量所以稍微有点难理解，因为外层的数组是代表每一行的数组，并不是每一列。之前没有提到，传递给<code>map</code>（或者类似<code>forEach</code>,<code>filter</code>这样的函数)的第二个参数，是当前元素的索引。通过映射第一行的元素，而且只映射第二个参数，<code>colWidths</code>给每一列索引建立一个数组。调用<code>reduce</code>运算的是外层的每一行数组，用于提出改行最宽的单元格和它的索引。<br>下面是绘制表格的代码：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawTable</span>(<span class="params">rows</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> heights = rowHeights(rows);</span><br><span class="line">  <span class="keyword">var</span> widths = colWidths(rows);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">drawLine</span>(<span class="params">blocks, lineNo</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blocks.map(<span class="function"><span class="keyword">function</span>(<span class="params">block</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> block[lineNo];</span><br><span class="line">    &#125;).join(<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">drawRow</span>(<span class="params">row, rowNum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> blocks = row.map(<span class="function"><span class="keyword">function</span>(<span class="params">cell, colNum</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cell.draw(widths[colNum], heights[rowNum]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> blocks[<span class="number">0</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">_, lineNo</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> drawLine(blocks, lineNo);</span><br><span class="line">    &#125;).join(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rows.map(drawRow).join(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>drawTable</code>这个函数调用了内部帮助函数<code>drawRow</code>去绘制每一行，然后在每一行末添加换行符。<br>首先<code>drawRow</code>函数把单元格对象转变为<code>blocks</code>，就是以行为单位，分割为包含单元格内容的字符串数组。一个只包含数字3376的单元格，转换后就是像[“3776”]这样的单个元素，带有下划线的单元格可能被转换为数组[“name”, “——“]。<br>一个block中的每一行的高度都相等，在最后的输出中应该保持相邻的位置。<code>drawRow</code>第二次调用<code>map</code>，从最左边的block开始逐行绘制输出表格。并且在逐行绘制的同时，记录下表格里最宽的那行。然后在每一行末添加换行符，把整行当作是<code>drawRow</code>的返回值。<br><code>drawLine</code>函数用于提取block数组中相邻的行，并且在行之间添加一个空格，这样每列之间就有了一个字符间隔的空格。<br>现在我们为包含字符的单元格写一个构造函数，实现了单元格的接口。构造函数用<code>split</code>方法把字符串分割为数组。在字符串中，<code>split</code>函数在每个传入参数出现的地方，都会将字符串分割，并且返回每个小部分组成的数组。<code>minWidth</code>函数返回这个数组最宽的行。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">string, times</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">    result += string;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextCell</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.text = text.split(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">TextCell.prototype.minWidth = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.text.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">width, line</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(width, line.length);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line">TextCell.prototype.minHeight = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.text.length;</span><br><span class="line">&#125;;</span><br><span class="line">TextCell.prototype.draw = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> line = <span class="keyword">this</span>.text[i] || <span class="string">""</span>;</span><br><span class="line">    result.push(line + repeat(<span class="string">" "</span>, width - line.length));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码使用了一个叫<code>repeat</code>的帮助函数，它用于构建一个重复的字符串，重复的内容是第一个参数，重复次数为第二个参数。<code>draw</code>方法给每一行添加了一个padding，使得每一行长度相同。<br>我们试着用以上方法创建一个 5 × 5 的棋盘格。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rows = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">var</span> row = [];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">     <span class="keyword">if</span> ((j + i) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">       row.push(<span class="keyword">new</span> TextCell(<span class="string">"##"</span>));</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       row.push(<span class="keyword">new</span> TextCell(<span class="string">"  "</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   rows.push(row);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(drawTable(rows));</span><br><span class="line"><span class="comment">// → ##    ##    ##</span></span><br><span class="line"><span class="comment">//      ##    ##</span></span><br><span class="line"><span class="comment">//   ##    ##    ##</span></span><br><span class="line"><span class="comment">//      ##    ##</span></span><br><span class="line"><span class="comment">//   ##    ##    ##</span></span><br></pre></td></tr></table></figure>
<p>这是可行的！但是由于每个单元格大小相等，格式化表格的函数实际上没有做任何事。<br>我们在这里使用的山脉数据可以在<a href="http://eloquentjavascript.net/code/mountains.js" target="_blank" rel="noopener">这里下载</a>。<br>我们需要使用下划线强调一下第一行，也就是列名。这不是大问题，我们只需要写一个带有下划线类型的单元格。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UnderlinedCell</span>(<span class="params">inner</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.inner = inner;</span><br><span class="line">&#125;</span><br><span class="line">UnderlinedCell.prototype.minWidth = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.inner.minWidth();</span><br><span class="line">&#125;;</span><br><span class="line">UnderlinedCell.prototype.minHeight = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.inner.minHeight() + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">UnderlinedCell.prototype.draw = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.inner.draw(width, height - <span class="number">1</span>)</span><br><span class="line">    .concat([repeat(<span class="string">"-"</span>, width)]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>带有下划线的单元格还包含另一个单元格。它需要获取内部单元格的大小（通过调用<code>minWidth</code>和<code>minHeight</code>方法），但是最后单元格高度需要加1，因为下划线也占了一行。<br>绘制这样一个单元格很简单，我们在原先的内容下增加下划线就可以了。<br>有了绘制下划线的函数，现在我们可以写一个为我们的数据集绘制单元格的函数。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataTable</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(data[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">var</span> headers = keys.map(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnderlinedCell(<span class="keyword">new</span> TextCell(name));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> body = data.map(<span class="function"><span class="keyword">function</span>(<span class="params">row</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keys.map(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TextCell(<span class="built_in">String</span>(row[name]));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> [headers].concat(body);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(drawTable(dataTable(MOUNTAINS)));</span><br><span class="line"><span class="comment">// → name         height country</span></span><br><span class="line"><span class="comment">//   ------------ ------ -------------</span></span><br><span class="line"><span class="comment">//   Kilimanjaro  5895   Tanzania</span></span><br><span class="line"><span class="comment">//   … etcetera</span></span><br></pre></td></tr></table></figure>
<p>标准的<code>Object.keys</code>函数返回一个对象，带有名称的数组。表格第一行必须包含有下划线单元格，表示列的名称。然后下面就是所有数据集中的数据内容，我们通过映射所有数据的<code>key</code>，来确保每一行的单元格顺序不出错。<br>输出的数据格式如上，除了没有<code>height</code>这列没有正确对齐。我们等一下会讲到这一点。</p>
<hr>
<h3 id="获取器和设置器"><a href="#获取器和设置器" class="headerlink" title="获取器和设置器"></a>获取器和设置器</h3><p>指定接口的时候，是可以包含不是方法的属性。我们可以定义<code>minHeight</code>和<code>minWidth</code>只返回数字。但这就要求在构造函数中做运算，实际上这一部分代码并不是和构造这个对象很相关。会造成一些问题，比如带有下划线单于格的内部单元格发生了改变，那么下划线单元格的大小也会改变。<br>这就导致有一些人从不在接口中传递非方法的属性。相比于直接获取一个单一的数值属性，他们更倾向于使用<code>getSomething</code>和<code>setSomething</code>方法去读写属性。这种办法也有缺点，就是你需要写（或者读）一些额外的代码。<br>幸运的是，JavaScript提供了一个两全其美的办法。我们可以这样设定，从外部看起来像是传递数值，但实际上传递了一个相关联的方法。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pile = &#123;</span><br><span class="line">  elements: [<span class="string">"eggshell"</span>, <span class="string">"orange peel"</span>, <span class="string">"worm"</span>],</span><br><span class="line">  get height() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.elements.length;</span><br><span class="line">  &#125;,</span><br><span class="line">  set height(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Ignoring attempt to set height to"</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pile.height);</span><br><span class="line"><span class="comment">// → 3</span></span><br><span class="line">pile.height = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// → Ignoring attempt to set height to 100</span></span><br></pre></td></tr></table></figure>
<p>从字面上理解，<code>get</code>或者<code>set</code>可以用于指定读写属性值时候调用的函数。你也可以给已经存在的对象添加这样的属性，比如<code>Object.defineProperty</code>给原型添加属性（之前使用过这个方法创建了不可枚举属性）。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(TextCell.prototype, <span class="string">"heightProp"</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.text.length; &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cell = <span class="keyword">new</span> TextCell(<span class="string">"no\nway"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cell.heightProp);</span><br><span class="line"><span class="comment">// → 2</span></span><br><span class="line">cell.heightProp = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(cell.heightProp);</span><br><span class="line"><span class="comment">// → 2</span></span><br></pre></td></tr></table></figure>
<p>你还可以用一个类似<code>set</code>的属性，在对象中传递给<code>defineProperty</code>，去定义一些方法。当定义了获取器但没有定义设置器，就会忽略写入的方法。</p>
<hr>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>绘制表格的练习已经接近完成了。再加上数字列右侧对齐能提高可读性。我们需要再创建另一个类似<code>TextCell</code>的单元格，但不是给右边添加空白，而是加在左边，使得他们能够右对齐。<br>我们现在写一个新的构造函数，在原型中包含三个方法。但是原型自身也可以有原型，所以我们就可以通过一个聪明的方式去构建。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RTextCell</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  TextCell.call(<span class="keyword">this</span>, text);</span><br><span class="line">&#125;</span><br><span class="line">RTextCell.prototype = <span class="built_in">Object</span>.create(TextCell.prototype);</span><br><span class="line">RTextCell.prototype.draw = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> line = <span class="keyword">this</span>.text[i] || <span class="string">""</span>;</span><br><span class="line">    result.push(repeat(<span class="string">" "</span>, width - line.length) + line);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们复用了<code>TextCell</code>中的<code>minHeight</code>和<code>minWidth</code>方法。<code>RTextCell</code>和<code>TextCell</code>基本相同，只是<code>draw</code>方法博阿含的函数不同。<br>这种模式叫做<code>继承</code>。可以使我们使用相对少量的代码对已有的数据类型做小部分的改变。典型的就是新的构造函数会调用旧的构造函数，使用<code>call</code>方法为了传递给新的对象<code>this</code>值。一旦这个构造函数被调用，我们就认为旧的对象类型的所有属性都被添加进新的对象。实例化的继承对象也有权限调用其原型的原型的属性。最终，我们可以通过添加新的原型重写某些属性。<br>现在，我们在<code>dataTable</code>使用<code>RTextCell</code>作为单元格函数，它的值就是一个数值，那我们就得到的一开始想要的表格。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataTable</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(data[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">var</span> headers = keys.map(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnderlinedCell(<span class="keyword">new</span> TextCell(name));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> body = data.map(<span class="function"><span class="keyword">function</span>(<span class="params">row</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keys.map(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> value = row[name];</span><br><span class="line">      <span class="comment">// This was changed:</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value == <span class="string">"number"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RTextCell(<span class="built_in">String</span>(value));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TextCell(<span class="built_in">String</span>(value));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> [headers].concat(body);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(drawTable(dataTable(MOUNTAINS)));</span><br><span class="line"><span class="comment">// → … beautifully aligned table</span></span><br></pre></td></tr></table></figure>
<p>继承是面向对象的基础的一部分，同样还有封装和多态。但是通常封装和多态都是被赞赏的，而继承存在争议。<br>原因是继承经常会和多态混淆，宣称是一个很强大的工具，但实际上经常被使用得很差。封装和多态可以分离代码片段，减少程序中代码的混乱程度，而继承基本上就是把代码联合在一起，增加混乱度。<br>如上，你可以不用继承实现多态。我不是告诉你要完全避免继承，我自己在我程序中也会经常用到继承。但是你要把它当作是一个减少定义代码量的小技巧，而不是组织代码原则。拓展<code>类型</code>更好的方式是通过组合，比如<code>UnderlinedCell</code>就是通过存储在一个属性中，在自己的方法中调用存储的属性这种方式，建立在另一个单元格对象之上。</p>
<hr>
<h3 id="INSTANCEOF运算符"><a href="#INSTANCEOF运算符" class="headerlink" title="INSTANCEOF运算符"></a>INSTANCEOF运算符</h3><p>有时候需要要知道一个对象是不是源于一个特定的构造函数，因此，JavaScript提供了二进制运算符<code>instanceof</code>。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> RTextCell(<span class="string">"A"</span>) <span class="keyword">instanceof</span> RTextCell);</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> RTextCell(<span class="string">"A"</span>) <span class="keyword">instanceof</span> TextCell);</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> TextCell(<span class="string">"A"</span>) <span class="keyword">instanceof</span> RTextCell);</span><br><span class="line"><span class="comment">// → false</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span><br><span class="line"><span class="comment">// → true</span></span><br></pre></td></tr></table></figure>
<p>这个运算符会逐级检查继承。<code>RTextCell</code>就是<code>TextCell</code>的一个实例化，因为<code>RTextCell.prototype</code>源于<code>TextCell.prototype</code>。这个操作符也可以被用于标准构造函数例如<code>Array</code>。几乎所有的对象都是<code>Object</code>的实例化。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以对象要比我最初描绘的复杂得多。他们有原型，同时原型又是另一个对象。而且只要原型对象中存在的属性，在继承对象中即使定义这个属性，它也会包含这个属性。简单对象的原型是<code>Object.prototype</code>。<br>构造函数通常都是以大写字母开头的一类函数，可以被<code>new</code>操作符来创建新的对象。新对象的原型可以在构造函数的<code>prototype</code>属性中找到。这一点可以好好利用，你可以把某一类型所有值都共享的属性放进他们的原型中。给定一个对象和构造函数，<code>instanceof</code>操作符可以判断该对象是否来源于制定构造函数。<br>有关对象很有用的一件事，就是去给它指定一个接口，然后告诉使用代码的人他们应该通过这个接口去和对象交互。剩余的构成你代码的细节部分都<code>封装</code>，隐藏在接口后面。<br>说到接口，谁说一个接口只能给一种对象应用？给不同的对象可以使用同一个接口，编写能够适用于多种对象的接口的代码，就叫做多态。这一点很有用。<br>当有多个数据类型它们的区别只在很小的细节部分，使用旧数据类型的原型去构建新数据类型的原型就很有用，而且可以在新的构造函数中调用旧的构造函数。这就能使得新的对象类似就的对象，但是你可以根据需求添加或重写属性。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/posts/56646/">Convert CSV to Geojson in Python</a><a class="next" href="/posts/49020/">How to Find Substrings in Python</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'chenyuzuoo';
var disqus_identifier = 'posts/24857/';
var disqus_title = '「译」JavaScript对象生命周期(Eloquent JavaScript 第六章)';
var disqus_url = 'https://chenyuzuoo.github.io/posts/24857/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//chenyuzuoo.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://chenyuzuoo.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ArcGIS/">ArcGIS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Latex/">Latex</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/R/">R</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sublime/">Sublime</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Theory/">Theory</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/writing-tool/" style="font-size: 15px;">writing, tool</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/design/" style="font-size: 15px;">design</a> <a href="/tags/ArcGIS-Pro/" style="font-size: 15px;">ArcGIS Pro</a> <a href="/tags/user-management/" style="font-size: 15px;">user management</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/pandas/" style="font-size: 15px;">pandas</a> <a href="/tags/web-mapping/" style="font-size: 21.5px;">web mapping</a> <a href="/tags/error-shooting/" style="font-size: 28px;">error shooting</a> <a href="/tags/visualization/" style="font-size: 15px;">visualization</a> <a href="/tags/writing/" style="font-size: 15px;">writing</a> <a href="/tags/installation/" style="font-size: 21.5px;">installation</a> <a href="/tags/text-processing/" style="font-size: 21.5px;">text processing</a> <a href="/tags/front-end/" style="font-size: 15px;">front end</a> <a href="/tags/listener/" style="font-size: 15px;">listener</a> <a href="/tags/model/" style="font-size: 15px;">model</a> <a href="/tags/tools/" style="font-size: 15px;">tools</a> <a href="/tags/spatial-query/" style="font-size: 15px;">spatial query</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/data-visualization/" style="font-size: 15px;">data visualization</a> <a href="/tags/snippet/" style="font-size: 15px;">snippet</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/PostgreSQL/" style="font-size: 15px;">PostgreSQL</a> <a href="/tags/GeoServer/" style="font-size: 15px;">GeoServer</a> <a href="/tags/Leaflet/" style="font-size: 15px;">Leaflet</a> <a href="/tags/ArcGIS/" style="font-size: 15px;">ArcGIS</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/7349/">How to Draw a Horizon Chart with R</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4537/">CORS Error</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/37160/">Postgis Error on st_within</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/33608/">Show Changes in Latex</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/25922/">Latex Footnote in Figure Caption</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/23844/">Convert Two-dimensional Table to One-dimensional Table</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/35618/">Load External Geojson to Leaflet</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/18707/">Install Geopandas</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/31988/">Multiple Linear Regression in R</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/30557/">Spatial polygon area calculation by another polygon layer</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> Recent Comments</i></div><script type="text/javascript" src="//chenyuzuoo.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://qsli.github.io/" title="KL's Blog" target="_blank">KL's Blog</a><ul></ul><a href="https://shuoyanhuang.github.io/" title="S.Huang's Personal Page" target="_blank">S.Huang's Personal Page</a></div><div class="widget"><div class="widget-title"><i class="fa fa-view-o"> View Record</i></div></div>Total<span id="busuanzi_container_site_pv"><span> </span><span rel="nofollow" id="busuanzi_value_site_pv"></span><span rel="nofollow">  hits, </span></span><span id="busuanzi_container_site_uv"><span rel="nofollow" id="busuanzi_value_site_uv"></span><span rel="nofollow">  vistors.</span></span></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Chenyu's Script.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>