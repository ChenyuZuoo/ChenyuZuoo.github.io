<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Einstiegen bitte!"><meta name="google-site-verification" content="L7-zLUxhF4WYJprTtGO0jUL7BYmE9BrpzuwU7s_XEJI"><title>「译」JavaScript正则表达式应用(Eloquent JavaScript 第九章) | Chenyu's Script</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-91094510-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">「译」JavaScript正则表达式应用(Eloquent JavaScript 第九章)</h1><a id="logo" href="/.">Chenyu's Script</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about.html"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">「译」JavaScript正则表达式应用(Eloquent JavaScript 第九章)</h1><div class="post-meta">Mar 14, 2017<span> | </span><span class="category"><a href="/categories/JavaScript/">JavaScript</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="posts/52949/" href="/posts/52949/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建一个正则表达式"><span class="toc-number">1.</span> <span class="toc-text">创建一个正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配测试"><span class="toc-number">2.</span> <span class="toc-text">匹配测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配一组字符串"><span class="toc-number">3.</span> <span class="toc-text">匹配一组字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重复部分模式"><span class="toc-number">4.</span> <span class="toc-text">重复部分模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分组表达式"><span class="toc-number">5.</span> <span class="toc-text">分组表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配和分组"><span class="toc-number">6.</span> <span class="toc-text">匹配和分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间类型"><span class="toc-number">7.</span> <span class="toc-text">时间类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字和字符串的边界"><span class="toc-number">8.</span> <span class="toc-text">字和字符串的边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择模式"><span class="toc-number">9.</span> <span class="toc-text">选择模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配机制"><span class="toc-number">10.</span> <span class="toc-text">匹配机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回溯"><span class="toc-number">11.</span> <span class="toc-text">回溯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#替换方法"><span class="toc-number">12.</span> <span class="toc-text">替换方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#贪婪"><span class="toc-number">13.</span> <span class="toc-text">贪婪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态创建正则表达式对象"><span class="toc-number">14.</span> <span class="toc-text">动态创建正则表达式对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找"><span class="toc-number">15.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LastIndex属性"><span class="toc-number">16.</span> <span class="toc-text">LastIndex属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环匹配"><span class="toc-number">17.</span> <span class="toc-text">循环匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析INI文件"><span class="toc-number">18.</span> <span class="toc-text">解析INI文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#国际字符"><span class="toc-number">19.</span> <span class="toc-text">国际字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">20.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>此文翻译《Eloquent Javascript》中第九章，<a href="http://eloquentjavascript.net/09_regexp.html" target="_blank" rel="noopener">Regular Expressions</a>，侵删。<br>该书有中文译本出版。此译文仅作交流学习之用。</p>
<hr>
<blockquote>
<p>有人说，当我遇到一个问题的时候，我会说，我知道用正则表达式解决。那么他们就有两个问题了。<br>—— Jamie Zawinski<br>Yuan-Ma说，当你收获粮食时，需要更多的力量。当你获得一个问题的答案时，需要更多的代码。<br>—— Master Yuan-Ma, The Book of Programming</p>
</blockquote>
<p>编程工具和技术成长之路一直是混乱的，革命性的。它并不总是最优秀最聪明的那个获胜，而是那些能保证功能运行正常的最后才能活下来。举个例子，那些能够很好的和别的技术结合的编程工具。<br>在这章里，我会讲符合上述的一个工具，即正则表达式。正则表达式是一种描述字符串规律的方法。这是一个小且独立的语言，是JavaScript还有很多别的语言的一部分， 是个好用的小工具。<br>正则表达式很奇怪，但同时非常好用。它语法很神奇，JavaScript提供的接口也很笨拙。但不妨碍它是一个功能强大的字符串检索和处理工具。正确的理解正则表达式能让你成为一个更高效的程序员。</p>
<hr>
<h3 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h3><p>一个正则表达式就一个对象，可以通过<code>RegExp</code>构造函数创建，或者是作为一个斜杠<code>／</code>包围的文字值来写入。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">var</span> re2 = <span class="regexp">/abc/</span>;</span><br></pre></td></tr></table></figure>
<p>这两个正则表达式的对象<code>模式</code>相同：字母a后面跟着b，b后面跟着c。<br>使用<code>RegExp</code>构造函数时，<code>模式</code>被写为正常的字符串，所以对反斜杠也适用。<br>第二行中把表达式写在两个斜杠中间，对反斜杠的处理会有所不同。首先，因为斜杠代表一个<code>模式</code>的结束，所以就需要在<code>模式</code>内部的斜杠前加一个反斜杠。另外，如果斜杠不是某个特殊符号的一部分，它也会被保留下来，并且会改变<code>模式</code>的含义。比如<code>\n</code>。还有一些字符比如问号和加号，他们在正则表达式中有特殊的含义。如果这些符号需要作为字符串的一部分，也需要在这些字符前加反斜杠。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eighteenPlus = <span class="regexp">/eighteen\+/</span>;</span><br></pre></td></tr></table></figure>
<p>书写正确的正则表达式反斜杠转义，就需要知道正则表达式中每一个特殊符号的含义。但就目前来看还不太现实，所以在任何非字母，数字，或者空格的字符前加上反斜杠。</p>
<hr>
<h3 id="匹配测试"><a href="#匹配测试" class="headerlink" title="匹配测试"></a>匹配测试</h3><p>正则表达式对象拥有自己一系列的方法。最简单的就是<code>test</code>。给它传递一个字符串，它会返回一个布尔值，用于表示这个字符串是否包含符合表达式的<code>模式</code>。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/abc/</span>.test(<span class="string">"abcde"</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/abc/</span>.test(<span class="string">"abxde"</span>));</span><br><span class="line"><span class="comment">// → false</span></span><br></pre></td></tr></table></figure>
<p>一个只由非特殊符号组成的表达式，只用于表示这个字符串序列。如果<code>abc</code>出现在字符串的任何位置，<code>test</code>都会返回<code>true</code>。</p>
<hr>
<h3 id="匹配一组字符串"><a href="#匹配一组字符串" class="headerlink" title="匹配一组字符串"></a>匹配一组字符串</h3><p>测试一个字符串是否包含<code>abc</code>和调用<code>indexOf</code>的功能类似。正则表达式的功能更为强大，能够检测会更复杂的<code>模式</code>。<br>假设我们想要匹配任何数字。在正则表达式中，把字符放在方括号内，就表示会匹配方括号内的任何字符。<br>下面的两个式子都表示匹配任意数字：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0123456789]/</span>.test(<span class="string">"in 1992"</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-9]/</span>.test(<span class="string">"in 1992"</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br></pre></td></tr></table></figure>
<p>在方括号内，两个字符之间加<code>-</code>表示一定范围内的字符，顺序等同于Unicode编码。0-9在这个编码中就是以数字从小到大排列（编码48-57），所以<code>[0-9]</code>就表示从0到9的任意数字。<br>正则表达式中还有内置的简写字符串，用于表示一些常用的匹配项。</p>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d</td>
<td>Any digit character</td>
</tr>
<tr>
<td>\w</td>
<td>An alphanumeric character (“word character”)</td>
</tr>
<tr>
<td>\s</td>
<td>Any whitespace character (space, tab, newline, and similar)</td>
</tr>
<tr>
<td>\D</td>
<td>A character that is not a digit</td>
</tr>
<tr>
<td>\W</td>
<td>A nonalphanumeric character</td>
</tr>
<tr>
<td>\S</td>
<td>A nonwhitespace character</td>
</tr>
<tr>
<td>.</td>
<td>Any character except for newline</td>
</tr>
</tbody>
</table>
<p>所以我们可以用一下格式去匹配时间字符串，30-01-2003 15:20：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dateTime = <span class="regexp">/\d\d-\d\d-\d\d\d\d \d\d:\d\d/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(dateTime.test(<span class="string">"30-01-2003 15:20"</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="built_in">console</span>.log(dateTime.test(<span class="string">"30-jan-2003 15:20"</span>));</span><br><span class="line"><span class="comment">// → false</span></span><br></pre></td></tr></table></figure>
<p>这个表达式包含很多反斜杠，制造了太多背景噪音，让人很难去理解这个表达式多传递的<code>模式</code>。我们稍后会讲一个稍微升级一点的版本。<br>反斜杠也可以用在方括号中间。举个例子，<code>[\d.]</code>表示任何数字或者句点字符。但要注意句点符号，当它出现在方括号内部时，就失去了它的特殊含义。其他的特殊含义字符也类似，比如<code>+</code>。<br>为了反向验证字符串，就是待验证的字符串中不能出现正则表达式的<code>模式</code>，可以在中括号中添加一个插入符。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> notBinary = <span class="regexp">/[^01]/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(notBinary.test(<span class="string">"1100100010100110"</span>));</span><br><span class="line"><span class="comment">// → false</span></span><br><span class="line"><span class="built_in">console</span>.log(notBinary.test(<span class="string">"1100100010200110"</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="重复部分模式"><a href="#重复部分模式" class="headerlink" title="重复部分模式"></a>重复部分模式</h3><p>现在你已经知道了如何匹配单个数字，那么一个数字字符串（多余一个数字的数）该如何匹配呢？<br>当你在正则表达式后面加一个加号<code>+</code>时，表示这个元素可能重复出现。所以，<code>/\d+/</code>匹配的是一个或多于一个数字的字符串。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/'\d+'/</span>.test(<span class="string">"'123'"</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/'\d+'/</span>.test(<span class="string">"''"</span>));</span><br><span class="line"><span class="comment">// → false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/'\d*'/</span>.test(<span class="string">"'123'"</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/'\d*'/</span>.test(<span class="string">"''"</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br></pre></td></tr></table></figure>
<p>星号<code>*</code>的含义与之类似，但也匹配出现0次的<code>模式</code>。任何结尾出现星号的表达式永远会匹配，如果字符湖惨重没有出现匹配的<code>模式</code>，就是0匹配实例。<br>问号的含义是<code>模式</code>的一部分为可选，即可以出现0次或一次。在下面的例子中，字符<code>u</code>可以出现，但它没有出现的时候同样匹配。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> neighbor = <span class="regexp">/neighbou?r/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(neighbor.test(<span class="string">"neighbour"</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="built_in">console</span>.log(neighbor.test(<span class="string">"neighbor"</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br></pre></td></tr></table></figure>
<p>如果要指定一个<code>模式</code>的出现次数，需要用到花括号。在元素后面加上<code>{4}</code>，就表示该元素必须要出现4次。当然也可以指定出现次数的范围，<code>{2,4}</code>表示该元素出现至少2次至多4次。<br>下面的例子就是时间<code>模式</code>的另一种表示方法，可以匹配单个或两个数字的日期，月份还有时间。并且增加了可读性。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dateTime = <span class="regexp">/\d&#123;1,2&#125;-\d&#123;1,2&#125;-\d&#123;4&#125; \d&#123;1,2&#125;:\d&#123;2&#125;/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(dateTime.test(<span class="string">"30-1-2003 8:45"</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br></pre></td></tr></table></figure>
<p>你还可以指定一个开放的范围，在花括号中，省略逗号后面的数字。<code>{5,}</code>表示出现超过5次。</p>
<hr>
<h3 id="分组表达式"><a href="#分组表达式" class="headerlink" title="分组表达式"></a>分组表达式</h3><p>如果需要一次使用多个操作符，如<code>*</code>或者<code>+</code>，可使用括号。只要后续的操作符是相关联的，正则表达式中被括号括起来的部分就可以算作一个单独的元素。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cartoonCrying = <span class="regexp">/boo+(hoo+)+/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(cartoonCrying.test(<span class="string">"Boohoooohoohooo"</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br></pre></td></tr></table></figure>
<p>第一个和第二个<code>+</code>只表示<code>boo</code>和<code>hoo</code>中的第二个<code>o</code>，第三个<code>+</code>表示的是<code>hoo+</code>这个整体，检测的是一个或多个整体。<br>在表达式最后的<code>i</code>表示该表达式大小写不敏感，虽然表达式中都是小写，但还是可以检测到字符串中的<code>B</code>。</p>
<hr>
<h3 id="匹配和分组"><a href="#匹配和分组" class="headerlink" title="匹配和分组"></a>匹配和分组</h3><p><code>test</code>方法绝对是正则表达式匹配最简单的方式，它只告诉你是否匹配，没有更多的信息。正则表达式还有一个<code>exec</code>方法，如果没有找到匹配项会返回<code>null</code>，反之返回找到的匹配项。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> match = <span class="regexp">/\d+/</span>.exec(<span class="string">"one two 100"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match);</span><br><span class="line"><span class="comment">// → ["100"]</span></span><br><span class="line"><span class="built_in">console</span>.log(match.index);</span><br><span class="line"><span class="comment">// → 8</span></span><br></pre></td></tr></table></figure>
<p><code>exec</code>返回的对象有<code>index</code>属性，可以告诉我们匹配项的位置。除了这个，这个对象同时也是一个字符串，第一个元素就是我们想要找的匹配项。<br>字符串对象也有一个功能相似的<code>match</code>方法。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"one two 100"</span>.match(<span class="regexp">/\d+/</span>));</span><br><span class="line"><span class="comment">// → ["100"]</span></span><br></pre></td></tr></table></figure>
<p>当正则表达式中包含有圆括号括起来的子表达式时，所有匹配的项会作为数组返回。全部匹配的项会做为数组的第一个元素。第二个元素部分匹配，以此类推。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quotedText = <span class="regexp">/'([^']*)'/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(quotedText.exec(<span class="string">"she said 'hello'"</span>));</span><br><span class="line"><span class="comment">// → ["'hello'", "hello"]</span></span><br></pre></td></tr></table></figure>
<p>当一个字符串中完全没有可匹配的项时，那么输出值会是<code>undefined</code>。类似地，当某项多次匹配时，数组的最后一个元素是最后一个匹配项。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/bad(ly)?/</span>.exec(<span class="string">"bad"</span>));</span><br><span class="line"><span class="comment">// → ["bad", undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/(\d)+/</span>.exec(<span class="string">"123"</span>));</span><br><span class="line"><span class="comment">// → ["123", "3"]</span></span><br></pre></td></tr></table></figure>
<p>分组在提取部分字符串的时候非常有用。如果我们不只是想要验证字符串时候包含一个日期，而是同时想提取这个日期并且作为对象返回。我们可以用圆括号包含数字模式，使用<code>exec</code>返回日期数值。<br>我们绕了一圈终于要讨论一下JavaScript中日期和时间的存储方式。</p>
<hr>
<h3 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h3><p>JavaScript中有一个标准的日期对象，或者说是时间点，叫做<code>Data</code>。如果你<code>new</code>一个日期对象，将会得到当前日期和时间。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"><span class="comment">// → Wed Dec 04 2013 14:24:57 GMT+0100 (CET)</span></span><br></pre></td></tr></table></figure>
<p>你也可以创建一个特定的时间对象。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2009</span>, <span class="number">11</span>, <span class="number">9</span>));</span><br><span class="line"><span class="comment">// → Wed Dec 09 2009 00:00:00 GMT+0100 (CET)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2009</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999</span>));</span><br><span class="line"><span class="comment">// → Wed Dec 09 2009 12:59:59 GMT+0100 (CET)</span></span><br></pre></td></tr></table></figure>
<p>JavaScript按照惯例月份从0开始（所以12月是11），但是日期是从1开始。这一点很让人混淆，需要注意。<br>最后四个参数（小时，分钟，秒钟，还有毫秒）是可选项，默认值为0。<br>时间戳是一个毫秒为单位的数字，从1970年开始算起，1970年之前是负值（遵循Unix time约定，大概是1970年规定的）。<code>getTime</code>方法可以返回特定时间的时间戳数字。你可以想象，这个数字非常大。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">11</span>, <span class="number">19</span>).getTime());</span><br><span class="line"><span class="comment">// → 1387407600000</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1387407600000</span>));</span><br><span class="line"><span class="comment">// → Thu Dec 19 2013 00:00:00 GMT+0100 (CET)</span></span><br></pre></td></tr></table></figure>
<p>如果给<code>Date</code>构造函数传递一个参数，这个参数就会被当作这样的毫秒数值。通过创建一个新的<code>Date</code>对象并调用<code>getTime</code>，或者是<code>Date.now</code>，就可以得到当前的毫秒数。<br><code>Date</code>对象提供<code>getFullYear</code>，<code>getMonth</code>，<code>getDate</code>，<code>getHours</code>, <code>getMinutes</code>和<code>getSeconds</code>方法，用于提取相应的值。还有<code>getYear</code>会返回相对不那么有用的两位数的年份，例如94或者14。<br>将我们感兴趣的子表达式用小括号括起来，我们就可以很容易的从一个字符串里提取日期对象了。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findDate</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dateTime = <span class="regexp">/(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)-(\d&#123;4&#125;)/</span>;</span><br><span class="line">  <span class="keyword">var</span> match = dateTime.exec(string);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Number</span>(match[<span class="number">3</span>]),</span><br><span class="line">                  <span class="built_in">Number</span>(match[<span class="number">2</span>]) - <span class="number">1</span>,</span><br><span class="line">                  <span class="built_in">Number</span>(match[<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(findDate(<span class="string">"30-1-2003"</span>));</span><br><span class="line"><span class="comment">// → Thu Jan 30 2003 00:00:00 GMT+0100 (CET)</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="字和字符串的边界"><a href="#字和字符串的边界" class="headerlink" title="字和字符串的边界"></a>字和字符串的边界</h3><p>不幸的是，<code>findDate</code>也会从字符串”100-1-30000”提取出无意义的日期00-1-3000。这样的匹配可能会发正在字符串的任一位置，在这种情况下，它会从第二个字符开始，在倒数第二个字符结束。<br>如果我们想要强制扫面整个字符串，我们可以加上标签<code>^</code>和<code>&lt;div class=&quot;post-content&quot;。插入符会从输入的开端开始匹配，美元符号表示匹配结尾。所以</code>/^\d+$/<code>匹配连续的一个或者一串数字，</code>/^!/<code>匹配任意带有感叹号开端的字符串，</code>/x^/<code>不能匹配任何字符串（因为字符串开始之前不可能有x）。  
如果相反，我们只想要确保一个词语的开始和结束字符，我们可以使用</code>\b`。字符边界可以是开头或者结尾。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/cat/</span>.test(<span class="string">"concatenate"</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\bcat\b/</span>.test(<span class="string">"concatenate"</span>));</span><br><span class="line"><span class="comment">// → false</span></span><br></pre></td></tr></table></figure>
<p>注意边界符并不代表一个实际的字符。它只是强制正则表达式去匹配相应的模式。</p>
<hr>
<h3 id="选择模式"><a href="#选择模式" class="headerlink" title="选择模式"></a>选择模式</h3><p>如果我们想要找到一段文字不仅包含一个数字，还跟着例如<code>pig</code>，<code>cow</code>或者<code>chicken</code>，或者它们的复数形式。<br>我们可以写三个正则表达式，然后一个一个测试，但有更简洁的办法。管道字符<code>|</code>表示它两侧的表达式都可以作为备选。如下：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animalCount = <span class="regexp">/\b\d+ (pig|cow|chicken)s?\b/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(animalCount.test(<span class="string">"15 pigs"</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="built_in">console</span>.log(animalCount.test(<span class="string">"15 pigchickens"</span>));</span><br><span class="line"><span class="comment">// → false</span></span><br></pre></td></tr></table></figure>
<p>圆括号可以用来限制模式应用的部分，你也可以在两个模式之间接连使用多个选择表达式。</p>
<hr>
<h3 id="匹配机制"><a href="#匹配机制" class="headerlink" title="匹配机制"></a>匹配机制</h3><p>正则表达式可以看作流程图。以下例子是前面的家畜表达式：<br><img src="/images/regexp1.svg" alt="判断机制"><br>如果我们的表达式能顺利从左到右找到一个通路，就可以找到一个匹配的字符串。我们保存字符串里的一个当前位置，通过没个检验盒的时候，我们只验证当前位置之后的部分是否与标准匹配。<br>所以当我们试图用正则表达式验证<code>the 3 pigs</code>的时候，我们的处理流程是这样：</p>
<ul>
<li>在第四个位置，是一个词语边界，所以我们通过了第一个检验盒。</li>
<li>仍旧是第四个位置，我们找到了一个数字，所以可以通过第二个检验盒。</li>
<li>在第五个位置，有一条路径循环返回到第二个检验盒（数字）之前，剩下的部分继续在流程中向前走到空格位。因为字符串中含有空格，不是数字，所以我们通过了第二条路。</li>
<li>当前位置是第六位（从<code>pigs</code>开始），位于流程的三通分支处。我们这里没有<code>cow</code>或者<code>chicken</code>，但是有<code>cow</code>，所以可以通过这一分支。</li>
<li>在第九位置，三通分支之后，有一条路是跳过<code>s</code>直接指向最后的词语边界，还有一条路可以匹配<code>s</code>。我们这里又一个<code>s</code>，并不是一个词语边界，所以我们通过<code>s</code>这个检验盒。</li>
<li>现在我们位于第十位（字符串终点），并且只能匹配一个词语边界。字符串末尾是一个词语边界，所以我们能够顺利通过这个检验，并匹配这个字符串。</li>
</ul>
<p>概念上来讲，正则表达式匹配字符串的机制是这样：它从字符串头部开始寻找匹配。在以上例子中，字符串首位是一个词语边界，但其后没有数字，所以在第二个检验盒位置失败了。然后就移向字符串中的第二个字符，继续从这里查找匹配项，以此类推，直到找到一个匹配项，或者移动到字符串末尾，判断该字符串中不包含任何匹配项。</p>
<hr>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>正则表达式<code>/\b([01]+b|\d+|[\da-f]+h)\b/</code>匹配的是一个二进制数字后面加一个<code>b</code>，或者没有任何附加项的任意十进制数，或者一个十六进制数后面加一个<code>h</code>。下面是对应的流程图：<br><img src="/images/regexp2.svg" alt="流程图"><br>在匹配这个表达式的时候，通常在没有包含二进制数字的时候进入最上面的分支。举个例子，当检验<code>103</code>的时候，只有当<code>3</code>进入分支后才能判断匹配不符。这个字符串是符合我们检验标准的，但不符合当前第一个检验标准。<br>所以匹配器需要<code>回溯</code>。当进入一个分支时，它记录下当前的匹配位置（在本例中，从字符串初始位置开始，只通过了第一个词语边界检验盒），如果当前检验不能通过，执行回溯并且试着去匹配下一分支。对于字符串<code>103</code>来说，在检验到第三个字符之后，它会去匹配十进制数字分支。这个分支是检验成功的，然后根据需求返回。<br>一旦找到一个全匹配项，匹配器就结束工作。这意味着如果一个字符串能够匹配多个分支，只通过第一个匹配的检验盒（顺序按照正则表达式书写的顺序）。<br><code>回溯</code>也出现在重复运算符比如<code>+</code>和<code>*</code>中。如果你用<code>/^.*x/</code>去匹配<code>abcxe</code>，<code>.*</code>会首先试着去匹配整个字符串。然后匹配器才会知道在<code>模式</code>中还有<code>x</code>需要匹配。由于没有位于字符串末尾的<code>x</code>，所以星号会尝试寻找少一个字符的匹配项。但是匹配器没有在<code>abcx</code>之后找到<code>x</code>，所以它又<code>回溯</code>，星号的匹配项就是<code>abc</code>。现在找到了正确匹配的<code>x</code>，成功返回0-4位。<br>包含很多<code>回溯</code>的正则表达式也是可行的，当一个模式可以匹配不同的规则时使用。举个例子，当我们对于二进制表达式存疑时，我们可以写成<code>/([01]+)+b/</code>。<br><img src="/images/regexp3.svg" alt="流程图"><br>如果待匹配项是一串很长的二进制字符，而且后面没有<code>b</code>，这个匹配器会首先在数字内部循环。然后才知道字符串中没有<code>b</code>，然后<code>回溯</code>原位，再进入外面一层的循环，再失败，继续回溯到内循环。它会通过两个循环一直寻找所有可能的匹配项。这就意味着每增加一个字符，多一倍工作量。即便只是几个字符，匹配过程会一直继续下去。</p>
<hr>
<h3 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h3><p>字符串变量有内置方法<code>replace</code>，可以用于替换字符串中的部分字符。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"papa"</span>.replace(<span class="string">"p"</span>, <span class="string">"m"</span>));</span><br><span class="line"><span class="comment">// → mapa</span></span><br></pre></td></tr></table></figure>
<p>其中第一个变量也可以是正则表达式，符合正则表达式的字符将会被替换。增则表达式中的<code>g</code>选项，指定的是所有符合正则表达式的字符串将会被替换，不仅仅是第一个。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Borobudur"</span>.replace(<span class="regexp">/[ou]/</span>, <span class="string">"a"</span>));</span><br><span class="line"><span class="comment">// → Barobudur</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Borobudur"</span>.replace(<span class="regexp">/[ou]/g</span>, <span class="string">"a"</span>));</span><br><span class="line"><span class="comment">// → Barabadar</span></span><br></pre></td></tr></table></figure>
<p>通过给<code>replace</code>添加参数，或者使用<code>replaceAll</code>方法替换所有匹配项，都是可行的。但还有一些情况，只能用合适的正则表达式来计算。<br>正则表达式真正的强大的地方，在于我们可以使用分组去替换字符串。举个例子，我们有一个包含名字的很长的字符串，每个名字占一行，格式是<code>Lastname，Firstname</code>。如果我们想要去掉中间的逗号变成<code>Firstname Lastname</code>这样的格式，我们可以这样做：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="string">"Hopper, Grace\nMcCarthy, John\nRitchie, Dennis"</span></span><br><span class="line">    .replace(<span class="regexp">/([\w ]+), ([\w ]+)/g</span>, <span class="string">"$2 $1"</span>));</span><br><span class="line"><span class="comment">// → Grace Hopper</span></span><br><span class="line"><span class="comment">//   John McCarthy</span></span><br><span class="line"><span class="comment">//   Dennis Ritchie</span></span><br></pre></td></tr></table></figure>
<p>表达式中的的<code>$1</code>和<code>$2</code>表示圆括号的匹配项。<code>$1</code>表示第一个匹配项，<code>$2</code>表示第二个，以此类推。全部的匹配项可表示为<code>&gt;&lt;</code>。<br>除了字符串之外，还可以给<code>replace</code>传递一个函数作为第二个参数。对于每一个替换项，每一个匹配项都会作为参数调用这个函数，返回值会作为一个新的字符串。<br>下面是一个简单的例子：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"the cia and fbi"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.replace(<span class="regexp">/\b(fbi|cia)\b/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// → the CIA and FBI</span></span><br></pre></td></tr></table></figure>
<p>下面是一个更有意思的例子：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stock = <span class="string">"1 lemon, 2 cabbages, and 101 eggs"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minusOne</span>(<span class="params">match, amount, unit</span>) </span>&#123;</span><br><span class="line">  amount = <span class="built_in">Number</span>(amount) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (amount == <span class="number">1</span>) <span class="comment">// only one left, remove the 's'</span></span><br><span class="line">    unit = unit.slice(<span class="number">0</span>, unit.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (amount == <span class="number">0</span>)</span><br><span class="line">    amount = <span class="string">"no"</span>;</span><br><span class="line">  <span class="keyword">return</span> amount + <span class="string">" "</span> + unit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(stock.replace(<span class="regexp">/(\d+) (\w+)/g</span>, minusOne));</span><br><span class="line"><span class="comment">// → no lemon, 1 cabbage, and 100 eggs</span></span><br></pre></td></tr></table></figure>
<p>这个函数传入一个字符串作为参数，找到所有的数次和量词一起出现的组合，返回一个把数量减一的字符串。<br>(\d+)分组返回的是<code>amount</code>变量，(\w+)分组返回的是<code>unit</code>变量。函数中转换<code>amount</code>为数字变量，这个转换的前提是它作为<code>\d+</code>的匹配项，函数中还为0和1的情况设置了不同的处理机制。</p>
<hr>
<h3 id="贪婪"><a href="#贪婪" class="headerlink" title="贪婪"></a>贪婪</h3><p>用<code>replace</code>方法写一个能够去掉JavaScript代码中注释的函数是很难的。下面是一个简单的尝试：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stripComments</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> code.replace(<span class="regexp">/\/\/.*|\/\*[^]*\*\//g</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(stripComments(<span class="string">"1 + /* 2 */3"</span>));</span><br><span class="line"><span class="comment">// → 1 + 3</span></span><br><span class="line"><span class="built_in">console</span>.log(stripComments(<span class="string">"x = 10;// ten!"</span>));</span><br><span class="line"><span class="comment">// → x = 10;</span></span><br><span class="line"><span class="built_in">console</span>.log(stripComments(<span class="string">"1 /* a */+/* b */ 1"</span>));</span><br><span class="line"><span class="comment">// → 1  1</span></span><br></pre></td></tr></table></figure>
<p>在<code>|</code>算子之前的部分，匹配的是非新行的双斜杠后面的任意字符。需要注意的是多行注释。我们使用<code>[^]</code>（任意非空字符串）去匹配任意字符。这里不能只用一个<code>.</code>，因为块级注释可以跨行，而<code>.</code>不能跨行检索。<br>但是之前的代码还是出错了，为什么呢？<br>就像之前<code>回溯</code>中讲过的，表达式中的<code>[^]*</code>会尽可能多的匹配。如果下一部分不能匹配模式，那么匹配器会回退一个字符并且重新开始检索匹配项。在本例中，匹配器先识图匹配整个字符串，然后回溯。在回溯四个字符之后，<code>*／</code>找到了匹配项。这并不是我们想要的结果，原本的意图是找到简单的注释，而不是在整个代码中找到注释的结束符。<br>由于这样的机制，我们可以说重复算子（+，<em>，？和{}）具有贪婪属性，意味着这样的算子会尽可能多的匹配，并且回溯。如果你在这些算子后面接了<code>?</code> (+?, </em>?, ??, {}?)，这些算子就不再贪婪，而是尽可能少的去匹配，只有在不符合最小匹配的时候才去查找更多的匹配项。<br>这就是我们在本例中想要的结果。星号需要查找的是最小的<code>*/</code>匹配项，只需要找到一个注释块。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stripComments</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> code.replace(<span class="regexp">/\/\/.*|\/\*[^]*?\*\//g</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(stripComments(<span class="string">"1 /* a */+/* b */ 1"</span>));</span><br><span class="line"><span class="comment">// → 1 + 1</span></span><br></pre></td></tr></table></figure>
<p>正则表达式的很多bug就是，在该使用非贪婪算子的时候使用了贪婪算子。使用重复算子的时候，优先考虑非贪婪算子。</p>
<hr>
<h3 id="动态创建正则表达式对象"><a href="#动态创建正则表达式对象" class="headerlink" title="动态创建正则表达式对象"></a>动态创建正则表达式对象</h3><p>当你在写代码的时候，总有一些时候，你会不知道确切的要匹配的模式。比如说你想要在一个字符串中找出用户名，并用下划线标示。因为只有在程序跑起来之后才能知道用户名，所以你不可能用结合斜杠的查找方法。<br>但是你可以用一个正则表达式构造函数去做这件事，这里给出一个例子：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"harry"</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"Harry is a suspicious character."</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\b("</span> + name + <span class="string">")\\b"</span>, <span class="string">"gi"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(text.replace(regexp, <span class="string">"_$1_"</span>));</span><br><span class="line"><span class="comment">// → _Harry_ is a suspicious character.</span></span><br></pre></td></tr></table></figure>
<p>在这里我们使用双斜杠去表示<code>\b</code>边界符，因为这里我们写的是一个普通字符串，而不是一个斜杠包含的正则表达式。<code>RegExp</code>的第二个参数<code>gi</code>的意思是全局查找，而且大小写敏感。<br>但如果有个中二少年的名字是<code>dea+hl[]rd</code>，这就需要一个不敏感的正则表达式才能匹配，本例中检测不到这样的名字。<br>为了正常运行，我们在任何不确定的字符前都加上反斜杠。但是在任一字母前面加反斜杠，并不是一个好的习惯，比如<code>\b</code>和<code>\n</code>都有它们的特殊含义。但转义所有非字母或者空格都是安全的。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"dea+hl[]rd"</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"This dea+hl[]rd guy is super annoying."</span>;</span><br><span class="line"><span class="keyword">var</span> escaped = name.replace(<span class="regexp">/[^\w\s]/g</span>, <span class="string">"\\&gt;&lt;"</span>);</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\b("</span> + escaped + <span class="string">")\\b"</span>, <span class="string">"gi"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(text.replace(regexp, <span class="string">"_$1_"</span>));</span><br><span class="line"><span class="comment">// → This _dea+hl[]rd_ guy is super annoying.</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>正则表达式没有内置字符串的<code>indexOf</code>方法，但是它有别的方法，<code>search</code>，并且该方法只能被正则表达式调用。类似于<code>indexOf</code>，<code>search</code>返回的是表达式找到的匹配项的第一个位置，-1表示没有匹配项。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"  word"</span>.search(<span class="regexp">/\S/</span>));</span><br><span class="line"><span class="comment">// → 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"    "</span>.search(<span class="regexp">/\S/</span>));</span><br><span class="line"><span class="comment">// → -1</span></span><br></pre></td></tr></table></figure>
<p>不友好的是，<code>search</code>方法不能指定偏移（<code>indexOf</code>的第二个参数是偏移量）。</p>
<hr>
<h3 id="LastIndex属性"><a href="#LastIndex属性" class="headerlink" title="LastIndex属性"></a><code>LastIndex</code>属性</h3><p><code>exec</code>方法同样也有没有提供一个方便的给定开始检索的属性，但提供了一个不太方便的办法。<br>正则表达式对象也有自己的属性。其中的一个属性就是<code>source</code>，它包含了原始字符串。另一个属性是<code>lastIndex</code>，在某些情况下，它能够控制下一个检索开始的位置。<br>如果要使用这些属性，必须开启全局选项，而且<code>exec</code>方法必须能找到匹配项。再说一句，一个更合理的方法是给<code>exec</code>多传递一个参数，但是JavaScript没有给正则表达式提供这样的接口。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/y/g</span>;</span><br><span class="line">pattern.lastIndex = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> match = pattern.exec(<span class="string">"xyzzy"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match.index);</span><br><span class="line"><span class="comment">// → 4</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);</span><br><span class="line"><span class="comment">// → 5</span></span><br></pre></td></tr></table></figure>
<p>如果匹配成功，<code>exec</code>自动更新<code>lastIndex</code>属性的值为匹配的后面一个位置。如果没有匹配项，<code>lastIndex</code>重新设置为0，同时新建的正则表达式这个属性也是0。<br>当使用全局正则表达式多次调用<code>exec</code>，自动更新<code>lastIndex</code>导致问题出现。你的正则表达式会从上一次调用之后的位置之后开始。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> digit = <span class="regexp">/\d/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(digit.exec(<span class="string">"here it is: 1"</span>));</span><br><span class="line"><span class="comment">// → ["1"]</span></span><br><span class="line"><span class="built_in">console</span>.log(digit.exec(<span class="string">"and now: 1"</span>));</span><br><span class="line"><span class="comment">// → null</span></span><br></pre></td></tr></table></figure>
<p>另一个有意思的全局反应就是，它改变了<code>match</code>方法对字符串的作用。当调用一个全局正则表达式，它不是像<code>exec</code>一样返回一个数组，<code>match</code>会返回所有匹配的字符串，并组成一个数组。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Banana"</span>.match(<span class="regexp">/an/g</span>));</span><br><span class="line"><span class="comment">// → ["an", "an"]</span></span><br></pre></td></tr></table></figure>
<p>所以要小心使用全局表达式。只在适当的时候使用，调用<code>replace</code>还有调用<code>lastIndex</code>的时候使用，通常也只有这两个地方会用到。</p>
<hr>
<h3 id="循环匹配"><a href="#循环匹配" class="headerlink" title="循环匹配"></a>循环匹配</h3><p>一种常见的模式就是用<code>lastIndex</code>和<code>exec</code>在循环体内扫描，找出匹配的字符串。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="string">"A string with 3 numbers in it... 42 and 88."</span>;</span><br><span class="line"><span class="keyword">var</span> number = <span class="regexp">/\b(\d+)\b/g</span>;</span><br><span class="line"><span class="keyword">var</span> match;</span><br><span class="line"><span class="keyword">while</span> (match = number.exec(input))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Found"</span>, match[<span class="number">1</span>], <span class="string">"at"</span>, match.index);</span><br><span class="line"><span class="comment">// → Found 3 at 14</span></span><br><span class="line"><span class="comment">//   Found 42 at 33</span></span><br><span class="line"><span class="comment">//   Found 88 at 40</span></span><br></pre></td></tr></table></figure>
<p>这里使用了赋值表达式（=）。使用<code>match = number.exec(input)</code>，作为<code>while</code>成立的条件，每次迭代的时候执行匹配，把结果保存进变量，当没有匹配项的时候循环结束。</p>
<hr>
<h3 id="解析INI文件"><a href="#解析INI文件" class="headerlink" title="解析INI文件"></a>解析INI文件</h3><p>做为本章的总结，我们来看一个使用正则表达式的实际问题。想象我们正在编写一个可以自动从往上收集敌人信息的程序。（我们并不是真的在这里写这个程序，只是读取配置文件的部分，不好意思让你失望了）配置文件如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">searchengine=http://www.google.com/search?q=$1</span><br><span class="line">spitefulness=9.7</span><br><span class="line">; comments are preceded by a semicolon...</span><br><span class="line">; each section concerns an individual enemy</span><br><span class="line">[larry]</span><br><span class="line">fullname=Larry Doe</span><br><span class="line">type=kindergarten bully</span><br><span class="line">website=http://www.geocities.com/CapeCanaveral/11451</span><br><span class="line">[gargamel]</span><br><span class="line">fullname=Gargamel</span><br><span class="line">type=evil sorcerer</span><br><span class="line">outputdir=/home/marijn/enemies/gargamel</span><br></pre></td></tr></table></figure>
<p>具体的格式化规则（被广泛的使用，称做INI文件）如下：</p>
<ul>
<li>忽略空行和以分号开头的行</li>
<li>独立出[and]连接的句子</li>
<li>包含文数字后面加<code>=</code>的行，在当前部分增加一个设置</li>
<li>其他任何都是无效的</li>
</ul>
<p>我们的任务就是像上述要求把字符串转变成数组对象，每一项都有一个<code>name</code>属性，还有一个设置数组。每一个部分我们都需要这样一个对象，并且在开头还需要一个全局设置。<br>因为格式化需要逐行执行，开始就是需要把文件按行分割。在<a href="http://eloquentjavascript.net/06_object.html#split" target="_blank" rel="noopener">第六章</a>中我们讲过用<code>string.split(&quot;\n&quot;)</code>实现。但是在某些操作系统中，不仅使用换行符分割行，而是使用回车加换行符（”\r\n”）。正则表达式也可以作为<code>split</code>方法的参数，我们可以用正则表达式<code>/\r?\n/</code>去正确的分割<code>\n</code>或者<code>\r\n</code>换行的文件。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseINI</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Start with an object to hold the top-level fields</span></span><br><span class="line">  <span class="keyword">var</span> currentSection = &#123;<span class="attr">name</span>: <span class="literal">null</span>, <span class="attr">fields</span>: []&#125;;</span><br><span class="line">  <span class="keyword">var</span> categories = [currentSection];</span><br><span class="line">  </span><br><span class="line">  string.split(<span class="regexp">/\r?\n/</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">line</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> match;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^\s*(;.*)?$/</span>.test(line)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (match = line.match(<span class="regexp">/^\[(.*)\]$/</span>)) &#123;</span><br><span class="line">      currentSection = &#123;<span class="attr">name</span>: match[<span class="number">1</span>], <span class="attr">fields</span>: []&#125;;</span><br><span class="line">      categories.push(currentSection);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (match = line.match(<span class="regexp">/^(\w+)=(.*)$/</span>)) &#123;</span><br><span class="line">      currentSection.fields.push(&#123;<span class="attr">name</span>: match[<span class="number">1</span>],</span><br><span class="line">                                  value: match[<span class="number">2</span>]&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Line '"</span> + line + <span class="string">"' is invalid."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> categories;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这行代码会逐行去运行，运行的时候不断更新“当前部分”。首先，它用表达式<code>/^\s*(;.*)?$/</code>检测该行是不是应该被忽略。你知道它怎么运行吗？在括号内部的部分匹配的是注释，<code>?</code>确保匹配行只包含空格。<br>如果该行不是注释，代码会去检测该行是不是开始了一个新的部分。如果是，它会新建一个对象，添加子变量。<br>最后有意思的部分就是，如果该行是常规文字，那么就添加到当前部分的对象。<br>如果某行不符合任一上述规则，函数抛出错误。<br>注意要经常使用<code>^</code>和<code>&lt;div class=&quot;post-content&quot;，确保表达式匹配的是整个行，而不只是其中一部分。如果不注意这些问题在大部分代码中也可以正常运行，但是有时会表现得很奇怪，这样的bug很难追踪。</code>if (match = string.match(…))<code>和</code>while<code>条件的功能类似。你经常不能确定调用是不是能够成功匹配，所以对于这个检验，结果对象只能从</code>if<code>条件内部获得。为了不破坏</code>if<code>的结构，在</code>if`条件内，我们将匹配结果赋值给一个变量，并且立即使用。</p>
<hr>
<h3 id="国际字符"><a href="#国际字符" class="headerlink" title="国际字符"></a>国际字符</h3><p>由于JavaScript最初设计简单，而且这一简单的设置再后来被当作标准确定下来，JavaScript中正则表达式对于非英语字符的处理很差。举个例子，对于JavaScript正则表达式，一个字母字符仅限于26个拉丁字母（包含大小写），还有下划线字符。像字符é或者β就不会匹配<code>\w</code>，而且会匹配<code>\W</code>（非字符类）。<br>由于一个奇怪的历史事件，<code>\s</code>没有这个问题，可以匹配所有标准Unicode空格字符，包括不间断空格和蒙古语元音分隔符。<br>在一些编程语言中，正则表达式有特殊的规则去匹配所有的Unicode字符，比如“all uppercase letters”, “all punctuation”, 或者 “control characters”。JavaScript也计划添加类似支持，但近期可能不会实现。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>正则表达式是代表字符串中某个模式的对象，拥有自己的语法去表达某个模式。</p>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>/abc/</td>
<td>A sequence of characters</td>
</tr>
<tr>
<td>/[abc]/</td>
<td>Any character from a set of characters</td>
</tr>
<tr>
<td>/[^abc]/</td>
<td>Any character not in a set of characters</td>
</tr>
<tr>
<td>/[0-9]/</td>
<td>Any character in a range of characters</td>
</tr>
<tr>
<td>/x+/</td>
<td>One or more occurrences of the pattern x</td>
</tr>
<tr>
<td>/x+?/</td>
<td>One or more occurrences, nongreedy</td>
</tr>
<tr>
<td>/x*/</td>
<td>Zero or more occurrences</td>
</tr>
<tr>
<td>/x?/</td>
<td>Zero or one occurrence</td>
</tr>
<tr>
<td>/x{2,4}/</td>
<td>Between two and four occurrences</td>
</tr>
<tr>
<td>/(abc)/</td>
<td>A group</td>
</tr>
<tr>
<td>/\d/</td>
<td>Any digit character</td>
</tr>
<tr>
<td>/\w/</td>
<td>An alphanumeric character (“word character”)</td>
</tr>
<tr>
<td>/\s/</td>
<td>Any whitespace character</td>
</tr>
<tr>
<td>/./</td>
<td>Any character except newlines</td>
</tr>
<tr>
<td>/\b/</td>
<td>A word boundary</td>
</tr>
<tr>
<td>/^/</td>
<td>Start of input</td>
</tr>
<tr>
<td>/$/</td>
<td>End of input</td>
</tr>
</tbody>
</table>
<p>正则表达式含有<code>test</code>内置方法，可以检测给定的字符串是否匹配。还有<code>exec</code>方法，当检测到匹配项，返回一个数组包含所有的匹配项。这样的数组具有<code>index</code>属性，指向匹配项开始的位置。<br>相对于正则表达式，字符串对象有内置的<code>match</code>方法，还有<code>search</code>方法去检测一个匹配值，只返回第一个匹配值的位置。<code>replace</code>方法可以用一个字符串替换掉匹配项。另外，还可以传递一个函数作为<code>replace</code>的参数，会基于匹配文字和匹配组新建字符串。<br>正则表达式也有可选项，写在闭合斜杠后。<code>i</code>表示大小写不敏感，<code>g</code>表示全局匹配，这样就可以使<code>replace</code>方法不止替换第一项，而是替换所有匹配项。<br><code>RegExp</code>构造函数可以用作从字符串创建一个正则表达式值。<br>正则表达式非常强大但是不容易使用。它很大程度上简化了计算，但是也会由于应用的复杂导致失控。对正则表达式的初步了解是不够的，而一旦掌握它，你就会疯狂的爱上它并且想用它表示一切东西。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/posts/58389/">Markdown Tools with Sublime</a><a class="next" href="/posts/16861/">3D Convex Hull</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'chenyuzuoo';
var disqus_identifier = 'posts/52949/';
var disqus_title = '「译」JavaScript正则表达式应用(Eloquent JavaScript 第九章)';
var disqus_url = 'https://chenyuzuoo.github.io/posts/52949/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//chenyuzuoo.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://chenyuzuoo.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ArcGIS/">ArcGIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Latex/">Latex</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/R/">R</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sublime/">Sublime</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Theory/">Theory</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/listener/" style="font-size: 15px;">listener</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/user-management/" style="font-size: 15px;">user management</a> <a href="/tags/design/" style="font-size: 15px;">design</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/text-processing/" style="font-size: 15px;">text processing</a> <a href="/tags/error-shooting/" style="font-size: 15px;">error shooting</a> <a href="/tags/installation/" style="font-size: 15px;">installation</a> <a href="/tags/tools/" style="font-size: 15px;">tools</a> <a href="/tags/ArcGIS-Pro/" style="font-size: 15px;">ArcGIS Pro</a> <a href="/tags/ArcGIS/" style="font-size: 15px;">ArcGIS</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a> <a href="/tags/web-mapping/" style="font-size: 15px;">web mapping</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/PostgreSQL/" style="font-size: 15px;">PostgreSQL</a> <a href="/tags/GeoServer/" style="font-size: 15px;">GeoServer</a> <a href="/tags/Leaflet/" style="font-size: 15px;">Leaflet</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/38366/">Leaflet Overlay OnEachFeature</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/27622/">Control Leadlet Overlays</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/14057/">ArcGIS_admin Python Module is Online</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4483/">Shapefile Import Failed</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/35459/">Drop All Tables in PostgreSQL</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3493/">An Investigation of Visual Analytics Maps</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8757/">A Detailed Introduction of Webmapping with WMS and Leaflet</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9583/">Build up Webmapping Environment on Windows</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/50946/">Start a Local Server with Python3</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/61525/">How to automatically vectorize raster images with Arcgis</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> Recent Comments</i></div><script type="text/javascript" src="//chenyuzuoo.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://qsli.github.io/" title="KL's Blog" target="_blank">KL's Blog</a><ul></ul><a href="https://shuoyanhuang.github.io/" title="S.Huang's Personal Page" target="_blank">S.Huang's Personal Page</a></div><div class="widget"><div class="widget-title"><i class="fa fa-view-o"> View Record</i></div></div>Total<span id="busuanzi_container_site_pv"><span> </span><span rel="nofollow" id="busuanzi_value_site_pv"></span><span rel="nofollow">  hits, </span></span><span id="busuanzi_container_site_uv"><span rel="nofollow" id="busuanzi_value_site_uv"></span><span rel="nofollow">  vistors.</span></span></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Chenyu's Script.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>