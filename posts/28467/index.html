<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Einstiegen bitte!"><meta name="google-site-verification" content="L7-zLUxhF4WYJprTtGO0jUL7BYmE9BrpzuwU7s_XEJI"><title>「译」JavaScript高阶函数(Eloquent JavaScript 第五章) | Chenyu's Script</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-91094510-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">「译」JavaScript高阶函数(Eloquent JavaScript 第五章)</h1><a id="logo" href="/.">Chenyu's Script</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about.html"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">「译」JavaScript高阶函数(Eloquent JavaScript 第五章)</h1><div class="post-meta">Jan 26, 2017<span> | </span><span class="category"><a href="/categories/JavaScript/">JavaScript</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="posts/28467/" href="/posts/28467/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象"><span class="toc-number">1.</span> <span class="toc-text">抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象字符串遍历"><span class="toc-number">2.</span> <span class="toc-text">抽象字符串遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高阶函数"><span class="toc-number">3.</span> <span class="toc-text">高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数传递"><span class="toc-number">4.</span> <span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON"><span class="toc-number">5.</span> <span class="toc-text">JSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组过滤"><span class="toc-number">6.</span> <span class="toc-text">数组过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Map函数转换"><span class="toc-number">7.</span> <span class="toc-text">使用Map函数转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reduce函数的总结"><span class="toc-number">8.</span> <span class="toc-text">Reduce函数的总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可组合性"><span class="toc-number">9.</span> <span class="toc-text">可组合性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成本"><span class="toc-number">10.</span> <span class="toc-text">成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#曾曾曾曾…（祖父）"><span class="toc-number">11.</span> <span class="toc-text">曾曾曾曾…（祖父）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#捆绑"><span class="toc-number">12.</span> <span class="toc-text">捆绑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">13.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#练习"><span class="toc-number">14.</span> <span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#过滤"><span class="toc-number">14.1.</span> <span class="toc-text">过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#母亲和孩子的年龄差"><span class="toc-number">14.2.</span> <span class="toc-text">母亲和孩子的年龄差</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#历史预期寿命"><span class="toc-number">14.3.</span> <span class="toc-text">历史预期寿命</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#every和some"><span class="toc-number">14.4.</span> <span class="toc-text">every和some</span></a></li></ol></li></ol></div></div><div class="post-content"><p>此文翻译《Eloquent Javascript》中第五章，<a href="http://eloquentjavascript.net/05_higher_order.html" target="_blank" rel="noopener">Higher-Order Functions</a>，侵删。<br>该书有<a href="https://book.douban.com/subject/19933548/" target="_blank" rel="noopener">中文译本</a>出版。此译文仅作交流学习之用。</p>
<hr>
<blockquote>
<p>Tzu-li和Tzu-ssu在互相吹嘘他们最近程序的代码行数，Tzu-li说他写了20万行，而且注释不算在内，Tzu-ssu说，嘘，我的已经接近一百万行了。Yuan-Ma老师说，我最好的程序只有五百行。听到这里，Tzu-li和Tzu-ssu恍然大悟。<br>———— Master Yuan-Ma, The Book of Programming</p>
<p>软件设计的路有两条：一条是设计简单，使其显然没有缺陷；另一条是设计复杂，使其没有明显的缺陷。<br>———— C.A.R. Hoare, 1980 ACM Turing Award Lecture</p>
</blockquote>
<p>一个大的程序是非常消耗资源的，不是简单的因为搭建程序所消耗的时间。程序的大小总是和它的复杂性相关，太复杂的程序会让程序员们更加困惑。复杂的程序往往会带来更多的错误。足够大的程序，同样有足够大的空间去隐藏各种各样难以调试的错误。<br>我们先简单回顾一下序章中的两个代码段，第一段代码的含义显而易见，共6行：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>, count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">  total += count;</span><br><span class="line">  count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(total);</span><br></pre></td></tr></table></figure>
<p>第二段代码依赖于两个外部函数，只有一行：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(range(<span class="number">1</span>, <span class="number">10</span>)));</span><br></pre></td></tr></table></figure>
<p>哪个代码段更有可能含有错误呢？<br>如果我们把<code>sum</code>和<code>range</code>函数也算在内，第二段代码甚至会比第一段代码更长。但依旧，第二段代码的正确率更高。<br>第二段代码正确率高的原因在于，它在一句话内就包含了相应问题的解决方式。某个范围之内的求和问题本身，并不包括循环和计数器。它只包括数字范围和数字求和。<br>这句代码的定义中（<code>sum</code>和<code>range</code>函数），还是会包含循环，计数器，还有别的必要的细节。但是分开表达的每个函数，都是很简单的概念，这就比融合在一起的一个程序，出错的概率小很多。</p>
<hr>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>在编程环境中，这些表达式通常被称为抽象。抽象能够隐藏掉细节，把问题抽象到一个更高的层次，更有利于探讨问题本身。<br>在编程过程中，我们不能总希望所有的“简单功能”(<code>sum</code>,<code>range</code>等)都已经存在。所以，有些人可能会按照自然计算的细节一步一步的让计算机实现某个功能。<br>对一个程序员来说，问题的解决需要需要变得“不那么自然”，需要意识到，把一个新的<code>概念</code>抽象为一个新的<code>功能</code>。</p>
<hr>
<h3 id="抽象字符串遍历"><a href="#抽象字符串遍历" class="headerlink" title="抽象字符串遍历"></a>抽象字符串遍历</h3><p>我们已经见过了很多次的常见函数，就是做抽象化很好的例子。但是有时候也具有一些不足。<br>在<a href="http://eloquentjavascript.net/04_data.html#data" target="_blank" rel="noopener">前面的章节</a>，这种类型的<code>for</code>循环已经出现过很多次：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> current = array[i];</span><br><span class="line">  <span class="built_in">console</span>.log(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的意思是说，在<code>console</code>中打印字符串中的每个元素。但是在这段代码中，又引入了计数器<code>i</code>，控制打印次数的循环，还有一个额外的用于打印的变量<code>current</code>增加了复杂度。除了看起来不够整齐，还为潜在的错误提供了更多的空间。我们有可能会不小心错误的复用了变量<code>i</code>，<code>length</code>拼写错为<code>lenght</code>，混淆了<code>i</code>和<code>current</code>，或者别的错误。<br>那么你能想一下，怎么样把这个过程抽象为一个函数呢？<br>首先，创建一个遍历数组中每个元素，并且同时调用<code>console.log</code>的函数并不难。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logEach</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">    <span class="built_in">console</span>.log(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果除了遍历数组之外我们还想做点变的事情呢？既然“做某件事”可以被表示为一个函数，函数就相当于一个值，那我们就可以将要做的事变成函数值。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">array, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">    action(array[i]);</span><br><span class="line">&#125;</span><br><span class="line">forEach([<span class="string">"Wampeter"</span>, <span class="string">"Foma"</span>, <span class="string">"Granfalloon"</span>], <span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// → Wampeter</span></span><br><span class="line"><span class="comment">// → Foma</span></span><br><span class="line"><span class="comment">// → Granfalloon</span></span><br></pre></td></tr></table></figure>
<p>（在某些浏览器中，并不可以这样调用<code>console.log</code>，可以用<code>alert</code>替代<code>console.log</code>）<br>通常情况下，你并不会传给<code>forEach</code>函数一些预定义函数，而是传入自己写的一些函数。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], sum = <span class="number">0</span>;</span><br><span class="line">forEach(numbers, <span class="function"><span class="keyword">function</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  sum += number;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br><span class="line"><span class="comment">// → 15</span></span><br></pre></td></tr></table></figure>
<p>这段代码函数体单独占一块，看起来很类似经典的<code>for</code>循环。但是，现在这个函数体是位于函数值之内，作为<code>forEach</code>函数的一个参数。这也是为什么函数以括号和分号结尾的原因。<br>在这个模型下，我们可以为现在的元素（数字）指定变量名，就比手动一个一个从数组中读出来要好。<br>事实上，我们不需要自己去写<code>forEach</code>函数。在数组中<code>forEach</code>是一个标准方法。因为数组已经默认提供了方法所要的所有元素，那么<code>forEach</code>就只需要一个变量：每个变量需要执行的函数。<br>为了说明以上非常有用，我们先来回看<a href="http://eloquentjavascript.net/04_data.html#analysis" target="_blank" rel="noopener">前面章节</a>的一个函数。这个函数包含两个数组遍历的循环。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gatherCorrelations</span>(<span class="params">journal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> phis = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> entry = <span class="number">0</span>; entry &lt; journal.length; entry++) &#123;</span><br><span class="line">    <span class="keyword">var</span> events = journal[entry].events;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; events.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> event = events[i];</span><br><span class="line">      <span class="keyword">if</span> (!(event <span class="keyword">in</span> phis))</span><br><span class="line">        phis[event] = phi(tableFor(event, journal));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> phis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>forEach</code>函数会让代码更简洁清爽。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gatherCorrelations</span>(<span class="params">journal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> phis = &#123;&#125;;</span><br><span class="line">  journal.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">    entry.events.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!(event <span class="keyword">in</span> phis))</span><br><span class="line">        phis[event] = phi(tableFor(event, journal));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> phis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>基于别的函数实现的函数，一种是把其他函数作为参数传入，另一种是返回一个函数，我们把这样的函数叫做<code>高阶函数</code>。如果你已经把函数当作一个普通的值，那么高阶函数的存在也没有什么特殊意义可言。这个术语来自于数学，数学中对函数和数值的概念有很大差别。<br>高阶函数是我们不仅能够抽象数值，还可以抽象‘动作’。高阶函数有几种不同的表现方式，比如，它可以用作创建新的函数。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greaterThan</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123; <span class="keyword">return</span> m &gt; n; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> greaterThan10 = greaterThan(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(greaterThan10(<span class="number">11</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br></pre></td></tr></table></figure>
<p>它还可以用作改变别的函数。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noisy</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"calling with"</span>, arg);</span><br><span class="line">    <span class="keyword">var</span> val = f(arg);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"called with"</span>, arg, <span class="string">"- got"</span>, val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">noisy(<span class="built_in">Boolean</span>)(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// → calling with 0</span></span><br><span class="line"><span class="comment">// → called with 0 - got false</span></span><br></pre></td></tr></table></figure>
<p>甚至它可以用来改写函数的控制流。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unless</span>(<span class="params">test, then</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!test) then();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">times, body</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; times; i++) body(i);</span><br><span class="line">&#125;</span><br><span class="line">repeat(<span class="number">3</span>, <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  unless(n % <span class="number">2</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n, <span class="string">"is even"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// → 0 is even</span></span><br><span class="line"><span class="comment">// → 2 is even</span></span><br></pre></td></tr></table></figure>
<p>在以上情境中，我们在<a href="http://eloquentjavascript.net/03_functions.html#scoping" target="_blank" rel="noopener">第三章</a>中讨论过的词汇作用域规则会对我们很有帮助。在前面的例子中，变量<code>n</code>就是外部函数的一个参数。因为内部函数在外部函数的作用域之内，所以它可以使用<code>n</code>。内部函数可以调用其对应外部函数的参数，相当于是普通循环和条件判断的<code>{}</code>块的作用。还有一个重要的规则，内部函数中声明的变量，并不会在外部函数中结束其生命周期。这是一件非常有利的事。</p>
<hr>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>之前我们定义的<code>noisy</code>函数，包含了其他函数的参数，是一个很大的设计缺陷。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noisy</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"calling with"</span>, arg);</span><br><span class="line">    <span class="keyword">var</span> val = f(arg);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"called with"</span>, arg, <span class="string">"- got"</span>, val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>f</code>传进的参数大于1，那么这里只能获得第一个参数。我们可以给它的内部函数添加一系列参数(arg1, arg2, 等等)，然后都传给<code>f</code>，但一共设置多少个参数比较合适我们并不知道。这个解决方法，同时会导致<code>argument.length</code>这个方法失效。所以我们最好是每次传递同样个数的参数，却并不知道原本有几个参数。<br>为了解决这类问题，JavaScript提供了<code>apply</code>方法。我们给它传入数组（或类数组）作为参数，它会调用相应参数的函数。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transparentWrapping</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是一个没有任何实际用途的函数，但是清晰的展示了我们感兴趣的解决办法，这个函数是根据传入的每一个参数，返回<code>f</code>对应的方法。具体就是通过传递每个<code>argument</code>到<code>apply</code>来实现。第一个传给<code>apply</code>的参数，我们这里传的是<code>null</code>，模拟了一个会被调用的方法。我们在<a href="http://eloquentjavascript.net/06_object.html#call_method" target="_blank" rel="noopener">下一章</a>中会作说明。</p>
<hr>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>在JavaScript中，高阶函数经常被用于处理数组中的各个元素。<code>forEach</code>方法的应用就是最典型的例子。数组中还有很多类似的方法。我们使用另一个数据集，来熟悉这些方法。<br>几年前，有人翻越了很多史料，编著了一本关于家族姓名的史书。我翻了一下希望找到有关骑士, 海盗和炼金术士的故事，但大部分都是讲弗拉明村民。只是自己感兴趣，我提取了自己直系祖先的信息，并把它制成一个计算机可读的文件。<br>文件如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;&quot;name&quot;: &quot;Emma de Milliano&quot;, &quot;sex&quot;: &quot;f&quot;,</span><br><span class="line">   &quot;born&quot;: 1876, &quot;died&quot;: 1956,</span><br><span class="line">   &quot;father&quot;: &quot;Petrus de Milliano&quot;,</span><br><span class="line">   &quot;mother&quot;: &quot;Sophia van Damme&quot;&#125;,</span><br><span class="line">  &#123;&quot;name&quot;: &quot;Carolus Haverbeke&quot;, &quot;sex&quot;: &quot;m&quot;,</span><br><span class="line">   &quot;born&quot;: 1832, &quot;died&quot;: 1905,</span><br><span class="line">   &quot;father&quot;: &quot;Carel Haverbeke&quot;,</span><br><span class="line">   &quot;mother&quot;: &quot;Maria van Brussel&quot;&#125;,</span><br><span class="line">  ……</span><br><span class="line">  ……</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这种格式的数据叫做JSON（JavaScript Object Notation），被广泛用作网络数据的存储和传输格式。<br>JSON很类似JavaScript中数组和对象的书写方式，当然也有一些限制。所有属性名称必须在双引号内部，而且只允许使用简单的数据表达式：不支持函数，变量，或者任何形式的计算。JSON中不能出现注释。<br>JavaScript中提供了相应的函数，<code>JSON.stringify</code>和<code>JSON.parse</code>，可以用作数据的格式转换。第一个函数是把JavaScript作为参数，返回JSON格式编码的字符串。第二个函数传入这样的字符串，解析为原本包含的信息。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>: <span class="string">"X"</span>, <span class="attr">born</span>: <span class="number">1980</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(string);</span><br><span class="line"><span class="comment">// → &#123;"name":"X","born":1980&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(string).born);</span><br><span class="line"><span class="comment">// → 1980</span></span><br></pre></td></tr></table></figure>
<p>变量<code>ANCESTRY_FILE</code>，包含了JSON格式的字符串，可以在<a href="http://eloquentjavascript.net/code/ancestry.js" target="_blank" rel="noopener">网上下载</a>。我们来看一下如何解码这个文件，里面包含了多少人。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ancestry = <span class="built_in">JSON</span>.parse(ANCESTRY_FILE);</span><br><span class="line"><span class="built_in">console</span>.log(ancestry.length);</span><br><span class="line"><span class="comment">// → 39</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="数组过滤"><a href="#数组过滤" class="headerlink" title="数组过滤"></a>数组过滤</h3><p>为了找出数据集中，在1924年的年轻人，以下的方法也许会有帮助。它剔除了数组中不能满足条件的人。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">array, test</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> passed = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (test(array[i]))</span><br><span class="line">      passed.push(array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> passed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(filter(ancestry, <span class="function"><span class="keyword">function</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.born &gt; <span class="number">1900</span> &amp;&amp; person.born &lt; <span class="number">1925</span>;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// → [&#123;name: "Philibert Haverbeke", …&#125;, …]</span></span><br></pre></td></tr></table></figure>
<p>这段代码使用<code>test</code>作为函数值的名称，填补了代码中的‘空隙’。数组中的每一个元素，都调用了<code>test</code>函数，它的返回值决定了该值是否继续留在数组内。<br>这里需要强调，是‘filter’函数建了一个能通过其过滤条件的新数组，而不是在已有的数组中删除元素。这个函数很纯净，不会修改原数组。<br>就像<code>forEach</code>，<code>filter</code>也是数组的标准方法之一。例子只是为了说明它内部的运作机制。从现在开始，我们应该这样使用：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ancestry.filter(<span class="function"><span class="keyword">function</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.father == <span class="string">"Carel Haverbeke"</span>;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// → [&#123;name: "Carolus Haverbeke", …&#125;]</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="使用Map函数转换"><a href="#使用Map函数转换" class="headerlink" title="使用Map函数转换"></a>使用Map函数转换</h3><p>假定我们现在手上有一组人名数据，从‘祖先’数组中过滤而来。但我们现在要的是只含有名字的数组，更方便读写。<br><code>map</code>方法是对数组中每个元素执行一个函数，并为返回值创建一个新的数组。新的数组和原数组长度相等，但是数组的每一个元素内容已经被执行的函数更新。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">array, transform</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mapped = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">    mapped.push(transform(array[i]));</span><br><span class="line">  <span class="keyword">return</span> mapped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> overNinety = ancestry.filter(<span class="function"><span class="keyword">function</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.died - person.born &gt; <span class="number">90</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(map(overNinety, <span class="function"><span class="keyword">function</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.name;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// → ["Clara Aernoudts", "Emile Haverbeke",</span></span><br><span class="line"><span class="comment">//    "Maria Haverbeke"]</span></span><br></pre></td></tr></table></figure>
<p>有趣的是，岁数超过90岁的名单，和我们之前见过的名单（1920s的年轻人）一样，这恰恰是我的数据集中离我们最近的一代。我猜是医学已经发展了。<br>就像<code>filter</code>和<code>forEach</code>函数，<code>map</code>也是数组中的一个标准方法。</p>
<hr>
<h3 id="Reduce函数的总结"><a href="#Reduce函数的总结" class="headerlink" title="Reduce函数的总结"></a>Reduce函数的总结</h3><p>另一个常见的数组计算，就是从数组中得到一个值。我们一直在用的一个例子，数字求和就是一个实例。另一个例子就是找到数据集中最早出生的那个人。<br>高阶函数中这种计算模式叫做<code>reduce</code>。你可以把它当作是对数组的一种折叠，每次执行一个元素。当对数字求和的时候，最好是从0开始，对每一个元素进行操作，把每一个元素和当前的和进行加和。<br><code>reduce</code>函数的参数，除了数组、组合方法，还需要一个开始位置。这个方法稍微比<code>filter</code>和<code>map</code>复杂一点，所以多注意一下。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">array, combine, start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = start;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">    current = combine(current, array[i]);</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reduce([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// → 10</span></span><br></pre></td></tr></table></figure>
<p>数组的标准方法<code>reduce</code>如上所示，还有一个方便的用途。如果你的数组至少包含两个元素，可以允许不写开始位置。该方法默认从数组第一个数值开始计算。<br>使用<code>reduce</code>从文件中找到年纪最大的祖先，可以使用代码段如下：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ancestry.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">min, cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cur.born &lt; min.born) <span class="keyword">return</span> cur;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> min;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// → &#123;name: "Pauwels van Haverbeke", born: 1535, …&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="可组合性"><a href="#可组合性" class="headerlink" title="可组合性"></a>可组合性</h3><p>考虑到我们之前的例子是用高级函数找到出生最早的人，代码还不至于这么差：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> min = ancestry[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; ancestry.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> cur = ancestry[i];</span><br><span class="line">  <span class="keyword">if</span> (cur.born &lt; min.born)</span><br><span class="line">    min = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(min);</span><br><span class="line"><span class="comment">// → &#123;name: "Pauwels van Haverbeke", born: 1535, …&#125;</span></span><br></pre></td></tr></table></figure>
<p>下面的代码增加了几个变量，代码行数虽然超过两行，但仍容易理解。<br>高阶函数的的好处就体现在当你想要组合几个函数的时候。举个例子，我们查找一下数据集中男人和女人的平均年龄。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">  <span class="keyword">return</span> array.reduce(plus) / array.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">age</span>(<span class="params">p</span>) </span>&#123; <span class="keyword">return</span> p.died - p.born; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">male</span>(<span class="params">p</span>) </span>&#123; <span class="keyword">return</span> p.sex == <span class="string">"m"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">female</span>(<span class="params">p</span>) </span>&#123; <span class="keyword">return</span> p.sex == <span class="string">"f"</span>; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(average(ancestry.filter(male).map(age)));</span><br><span class="line"><span class="comment">// → 61.67</span></span><br><span class="line"><span class="built_in">console</span>.log(average(ancestry.filter(female).map(age)));</span><br><span class="line"><span class="comment">// → 54.56</span></span><br></pre></td></tr></table></figure>
<p>（我们还需要自己定义<code>plus</code>有点蠢，但是JavaScript中的算子不是函数，不是某个值，所以我们不能像传递参数一样传递加号。）<br>在这里我们把各个函数组合起来（确定性别，计算平均数），而不是把所有的运算都糅合进一个大循环。我们可以一个一个执行，最终找到到问题的解决办法。<br>这对书写简洁优雅的代码非常重要，但是这样清晰的结构也有所代价。</p>
<hr>
<h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><p>在简洁优雅的代码生存的乐土里，还有一片乌云叫做<code>低效</code>。<br>程序处理数组的过程被优雅的分割为一系列小步骤，而且每次都计算出一个新的数组。但是创建这些中间数组非常耗资源。<br>比如说，给<code>forEach</code>传递函数去处理数组，字面上非常方便也容易理解。但是JavaScript中调用方程比简单的循环体更消耗资源。<br>还有很多的技巧帮我们提高代码的清晰度。<code>抽象</code>会给原始数据和我们想要做的计算中添加一个中间层，导致机器需要处理更多的工作。这也并不是一个铁律，还有很多语言可以支持构建抽象的同时不增加开销，甚至在JavaScript中，有经验的工程师可以构建出运行更快的<code>抽象</code>。但是这个问题很常见。<br>幸运的是，大部分计算机都快到飞起。如果你处理的是一个中等大小的数据集，或者是计算时间以人的时间为标准（用户单击鼠标的时间），那写一个需要运行半毫秒的解决方案，和写一个非常棒棒的只需要十分之一毫秒计算时间的解决方案，并没有太大区别。<br>持续跟踪程序中每一小块被调用的频率，会非常有帮助。如果有嵌套的循环（不管是直接嵌套，或者是外层循环调用一个函数，最终在内层函数中结束计算的），内层的代码段会被执行N<em>M次，在这里N表示外层循环次数，M表示内层循环次数。如果内层循环还包含别的需要运行P次的循环，整个代码段就会执行N</em>M*P次，以此类推。这样可能导致一个很长的运行时间，当一个程序非常慢的时候，问题通常会被追溯到一块非常小的代码段，通常位于一个内层循环中。</p>
<hr>
<h3 id="曾曾曾曾…（祖父）"><a href="#曾曾曾曾…（祖父）" class="headerlink" title="曾曾曾曾…（祖父）"></a>曾曾曾曾…（祖父）</h3><p>我的祖父菲力贝尔·哈伯贝克也在数据集中。从他开始往上，按血统我可以追溯到名单里年纪最大的人鲍维思·凡·哈伯贝克是不是我的直系祖先。如果他是的话，我很想知道理论上我有多少DNA来源于他。<br>为了能通过父母的名字获得代表这个人的对象，我们首先建立一个能把人和名字联系起来的对象。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> byName = &#123;&#125;;</span><br><span class="line">ancestry.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  byName[person.name] = person;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(byName[<span class="string">"Philibert Haverbeke"</span>]);</span><br><span class="line"><span class="comment">// → &#123;name: "Philibert Haverbeke", …&#125;</span></span><br></pre></td></tr></table></figure>
<p>现在，问题就不止简单是从<code>father</code>这个属性里，往上数到鲍维思一共有多少个人。在这个族谱中还有一些人和他们的表兄弟结婚。这会导致家族中的基因有些地方出现重合，说明我遗传的基因数会多过$1/2^G$，G代表鲍维思和我之间的间隔代数。这个公式基于每一代都把基因稀释为1/2。<br>思考这个问题的合理方式，就是把他当作是一种<code>reduce</code>，不断重复的把一个数组从左至右压缩到，成为一个单个的值。在本问题中，我们也同样是要把数据结构沿着族谱压缩至一个值。这个数据的形式是一个家族树，而不是一个单一的列表。<br>这里我们的压缩方式，就是找出某个给定的人的祖先。可以通过递归完成：假设给定的人为A，我们先计算出A的父母，然后计算出A的祖父母，一次类推。原则上讲，我们需要找无限个人，但实际上我们的数据集是有限的，所以总会在某个地方停下来。我们需要给压缩函数设置一个阈值，用做判断不在目标列表里的人。在本例中，这个值就是0，表示这个人和我们给定的人不享有同源DNA。<br>给定一个人，一个查找父母的函数，一个阈值，<code>reduceAcestors</code>就会从族谱中计算出一个值。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduceAncestors</span>(<span class="params">person, f, defaultValue</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">valueFor</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (person == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> defaultValue;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> f(person, valueFor(byName[person.mother]),</span><br><span class="line">                       valueFor(byName[person.father]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> valueFor(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部函数<code>valueFor</code>处理单个人，但通过递归，这个函数就可以调用自己计算这个人的父母的父母。结果是，通过这个人的对象，传值给<code>f</code>，最终把实际的值返回给这个人。<br>我们通过这个计算我祖父继承了多少鲍维思·凡·哈克贝尔的基因，并把这个数字除以4。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sharedDNA</span>(<span class="params">person, fromMother, fromFather</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (person.name == <span class="string">"Pauwels van Haverbeke"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> (fromMother + fromFather) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ph = byName[<span class="string">"Philibert Haverbeke"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(reduceAncestors(ph, sharedDNA, <span class="number">0</span>) / <span class="number">4</span>);</span><br><span class="line"><span class="comment">// → 0.00049</span></span><br></pre></td></tr></table></figure>
<p>很显然名叫鲍维思·凡·哈克贝尔的人，和鲍维思·凡·哈克贝尔（数据集中只有一个人叫这个名字）基因的相似度是100%，所以该函数返回1。所有其他人都只享有从父母处继承的一半的鲍维思·凡·哈克贝尔的基因。<br>统计学角度来讲，我和这位16世纪的人的基因有0.05%的相似度。需要提醒的是这只是统计估计，并不是真实的数据。虽然这只是一个很小的数字，但是考虑到每个人携带30亿个碱基对，在生物学上，我有些部分就源自于鲍维思。<br>我们也可以不通过<code>reduceAncestor</code>来计算。通过把成块的计算方法（压缩族谱）分解为小函数（计算基因相似度），可以提高代码的清晰度，增加代码的复用度。举个例子，下面的代码能够找出某个人祖先中年龄超过70岁的比例（根据血统查找，所以有些人可能被重复计算）。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countAncestors</span>(<span class="params">person, test</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">current, fromMother, fromFather</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> thisOneCounts = current != person &amp;&amp; test(current);</span><br><span class="line">    <span class="keyword">return</span> fromMother + fromFather + (thisOneCounts ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> reduceAncestors(person, combine, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longLivingPercentage</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> all = countAncestors(person, <span class="function"><span class="keyword">function</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> longLiving = countAncestors(person, <span class="function"><span class="keyword">function</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (person.died - person.born) &gt;= <span class="number">70</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> longLiving / all;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(longLivingPercentage(byName[<span class="string">"Emile Haverbeke"</span>]));</span><br><span class="line"><span class="comment">// → 0.129</span></span><br></pre></td></tr></table></figure>
<p>对这个结果不要太认真，我们的数据集没有普遍性。但是这段代码说明了<code>reduceAncestor</code>提供给我们一个计算族谱这种数据结构的很好用的代码段。</p>
<hr>
<h3 id="捆绑"><a href="#捆绑" class="headerlink" title="捆绑"></a>捆绑</h3><p><code>捆绑(binding)</code>是所有函数都有的一个方法，它会哈村建一个可以调用原函数的新函数，但是有一些参数已经被修改。<br>下面的代码展示了<code>捆绑</code>在例子中的应用。它定义了一个函数<code>isinSet</code>来判断一个人是否在一个给定的字符串之内。为了找出那些在特定数据集的人名对象，我们需要调用<code>filter</code>。我们可以写一个函数，<code>isInSet</code>作为其中一个参数，或者部分使用<code>isInSet</code>函数。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theSet = [<span class="string">"Carel Haverbeke"</span>, <span class="string">"Maria van Brussel"</span>,</span><br><span class="line">              <span class="string">"Donald Duck"</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInSet</span>(<span class="params">set, person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> set.indexOf(person.name) &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ancestry.filter(<span class="function"><span class="keyword">function</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isInSet(theSet, person);</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// → [&#123;name: "Maria van Brussel", …&#125;,</span></span><br><span class="line"><span class="comment">//    &#123;name: "Carel Haverbeke", …&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(ancestry.filter(isInSet.bind(<span class="literal">null</span>, theSet)));</span><br><span class="line"><span class="comment">// → … same result</span></span><br></pre></td></tr></table></figure>
<p>调用<code>bind</code>返回的是以<code>theSet</code>作为第一个参数的<code>isInSet</code>函数，然后是任何绑定给函数的参数。<br>第一个参数，这个例子中传递的是<code>null</code>，用作调用方法的参数，类似于<code>apply</code>的第一个参数。我会在<a href="http://eloquentjavascript.net/06_object.html#call_method" target="_blank" rel="noopener">下一章</a>中给出详细的解释。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>能够把函数作为值传给别的函数，不仅仅是一个小花招，而是JavaScript中非常实用的一个方面。这个设计能够让我们在写代码的时候留有一些‘空隙’，然后用函数值来填补这些‘空隙’。<br>数组中提供了很多高阶函数，<code>forEach</code>是针对数组中每个元素进行操作；<code>filter</code>会根据过滤的元素创建一个新数组；<code>map</code>用作给每个元素执行一个函数，并把结果创建为一个新的数组；<code>reduce</code>用于把所有元素合并为一个单一的值。<br>函数都有<code>apply</code>方法，用于对不同的参数调用不同的计算方式。同时还有一个<code>bind</code>方法，用于去创建某个部分使用另一个函数的函数。</p>
<hr>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><p>结合<code>reduce</code>和<code>concat</code>方法，能把多个数组结合成一个包含每个元素的单个数组。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrays = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>]];</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"><span class="comment">// → [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<h4 id="母亲和孩子的年龄差"><a href="#母亲和孩子的年龄差" class="headerlink" title="母亲和孩子的年龄差"></a>母亲和孩子的年龄差</h4><p>使用本章的数据集，计算母亲和孩子的平均年龄差（母亲生小孩时的年龄）。可以使用本章中的<code>average</code>函数。<br>注意并非所有提到的母亲都在数据集当中。使用<code>byName</code>找到名字所对应的对象，可能会有帮助。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">  <span class="keyword">return</span> array.reduce(plus) / array.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> byName = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ancestry.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  byName[person.name] = person;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// → 31.2</span></span><br></pre></td></tr></table></figure>
<h4 id="历史预期寿命"><a href="#历史预期寿命" class="headerlink" title="历史预期寿命"></a>历史预期寿命</h4><p>我们查找出数据集中寿命超过90岁的人，会发现这些人质存在在最后一代中。那我们再仔细研究一下这个现象。<br>计算并显示数据集中每个世纪的平均寿命。确定一个人属于哪个世纪的方法：卒年除以100，然后进位，比如<code>Math.ceil(person.died / 100)</code>。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">  <span class="keyword">return</span> array.reduce(plus) / array.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// → 16: 43.5</span></span><br><span class="line"><span class="comment">//   17: 51.2</span></span><br><span class="line"><span class="comment">//   18: 52.8</span></span><br><span class="line"><span class="comment">//   19: 54.8</span></span><br><span class="line"><span class="comment">//   20: 84.7</span></span><br><span class="line"><span class="comment">//   21: 94</span></span><br></pre></td></tr></table></figure>
<p>附加分：写一个分组函数<code>groupBy</code>。<code>groupBy</code>函数应该接受两个参数，一个是数组，还有一个是函数，这个函数为每一个元素计算其分组，并返回带有名称的分好组的数据。</p>
<h4 id="every和some"><a href="#every和some" class="headerlink" title="every和some"></a>every和some</h4><p>每个数组都有标准方法<code>every</code>和<code>some</code>。两个都是断言函数，当我们给这两个函数传入数组作为参数，他们的返回是true或者false。就像 &amp;&amp; 只有在两边的表达式都为真的时候才返回true，<code>every</code>只有在数组中所有元素都为真的时候才返回true。类似地，<code>some</code>在数组中任意元素为真时返回true。他们在不必要时不会做更多的计算，比如，如果<code>some</code>找到的第一个元素为真，就不会继续向后查找。<br>写两个函数，<code>every</code>和<code>some</code>，功能类似上述，但是这里数组作为一个参数。而不是数组中的一个方法。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(every([<span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>], <span class="built_in">isNaN</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="built_in">console</span>.log(every([<span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="number">4</span>], <span class="built_in">isNaN</span>));</span><br><span class="line"><span class="comment">// → false</span></span><br><span class="line"><span class="built_in">console</span>.log(some([<span class="literal">NaN</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="built_in">isNaN</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="built_in">console</span>.log(some([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="built_in">isNaN</span>));</span><br><span class="line"><span class="comment">// → false</span></span><br></pre></td></tr></table></figure></div><div class="tags"></div><div class="post-nav"><a class="pre" href="/posts/40228/">个人博客搜索引擎优化</a><a class="next" href="/posts/7862/">从前端配色问题的解决方案到一通胡扯</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'chenyuzuoo';
var disqus_identifier = 'posts/28467/';
var disqus_title = '「译」JavaScript高阶函数(Eloquent JavaScript 第五章)';
var disqus_url = 'https://chenyuzuoo.github.io/posts/28467/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//chenyuzuoo.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://chenyuzuoo.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ArcGIS/">ArcGIS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Latex/">Latex</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/R/">R</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sublime/">Sublime</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Theory/">Theory</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/model/" style="font-size: 15px;">model</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/user-management/" style="font-size: 15px;">user management</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/design/" style="font-size: 15px;">design</a> <a href="/tags/web-mapping/" style="font-size: 21.5px;">web mapping</a> <a href="/tags/pandas/" style="font-size: 15px;">pandas</a> <a href="/tags/text-processing/" style="font-size: 21.5px;">text processing</a> <a href="/tags/error-shooting/" style="font-size: 28px;">error shooting</a> <a href="/tags/installation/" style="font-size: 21.5px;">installation</a> <a href="/tags/typesetting/" style="font-size: 15px;">typesetting</a> <a href="/tags/ArcGIS-Pro/" style="font-size: 15px;">ArcGIS Pro</a> <a href="/tags/listener/" style="font-size: 15px;">listener</a> <a href="/tags/tools/" style="font-size: 15px;">tools</a> <a href="/tags/snippet/" style="font-size: 15px;">snippet</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/ArcGIS/" style="font-size: 15px;">ArcGIS</a> <a href="/tags/data-visualization/" style="font-size: 15px;">data visualization</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/PostgreSQL/" style="font-size: 15px;">PostgreSQL</a> <a href="/tags/GeoServer/" style="font-size: 15px;">GeoServer</a> <a href="/tags/Leaflet/" style="font-size: 15px;">Leaflet</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/25922/">Latex Footnote in Figure Caption</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/23844/">Convert Two-dimensional Table to One-dimensional Table</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/35618/">Load External Geojson to Leaflet</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/18707/">Install Geopandas</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/31988/">Multiple Linear Regression in R</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/30557/">Spatial polygon area calculation by another polygon layer</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/17204/">How to Draw Interactive Steamgraph in R</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/39979/">Extract Column from Tables</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/38366/">Leaflet Overlay OnEachFeature</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/27622/">Control Leadlet Overlays</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> Recent Comments</i></div><script type="text/javascript" src="//chenyuzuoo.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://qsli.github.io/" title="KL's Blog" target="_blank">KL's Blog</a><ul></ul><a href="https://shuoyanhuang.github.io/" title="S.Huang's Personal Page" target="_blank">S.Huang's Personal Page</a></div><div class="widget"><div class="widget-title"><i class="fa fa-view-o"> View Record</i></div></div>Total<span id="busuanzi_container_site_pv"><span> </span><span rel="nofollow" id="busuanzi_value_site_pv"></span><span rel="nofollow">  hits, </span></span><span id="busuanzi_container_site_uv"><span rel="nofollow" id="busuanzi_value_site_uv"></span><span rel="nofollow">  vistors.</span></span></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Chenyu's Script.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>